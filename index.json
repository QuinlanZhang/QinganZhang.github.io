[{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/","summary":"","title":"[Effective Modern Cpp Notes] Ch08 微调"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/","summary":"","title":"[Effective Modern Cpp Notes] Ch07 并发API"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-cpp/effective-cpp-reading-notes/","summary":"","title":"Effective Cpp Reading Notes"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/","summary":"","title":"Effective Modern Cpp Reading Notes"},{"content":"31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但是可以更容易发现此处可能有引用悬挂 默认传值捕获也可能导致引用悬挂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std::vector\u0026lt;std::function\u0026lt;bool(int)\u0026gt;\u0026gt; filters; class Widget{ public: // void addFilter() const{ // filters.emplace_back( // [=](int value) {return value % divisor == 0;} // ); // 看似是传值捕获，不会有引用悬挂；但是lambda只能捕获作用域中的非静态局部变量，此处的divisor其实是this-\u0026gt;divisor，容易产生引用悬挂 // } // 解决方法：使用一个局部变量复制成员变量，然后使用显式的值捕获 void addFilter() const{ int divisorCopy = divisor; filters.emplace_back( [divisorCopy] (int value) {return value % divisorCopy == 0;} ); } private: int divisor; }; lambda只能捕获作用域中的非静态局部变量，无法捕获静态或全局变量 捕获表示将值拷贝到闭包类中，而lambda中使用静态或全局变量，相当于是对外部的引用，因此此时lambda不是独立的 参考 https://blog.csdn.net/Dong_HFUT/article/details/125037605 32：使用初始化捕获将对象移入闭包 C++14使用初始化捕获模式（也称广义lambda捕获）来实现移动捕获 1 2 3 4 5 struct Widget{ bool isValid() const; }; auto func = [pw = std::make_unique\u0026lt;Widget\u0026gt;()] // 左边是lambda闭包内成员名称，右边是初始化 {return pw-\u0026gt;isValid();} C++11使用std::bind间接实现移动捕获 1 2 3 4 5 6 7 struct Widget{ bool isValid() const; }; auto func = std::bind( [] (const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; pw) {return pw-\u0026gt;isValid();}, std::make_unique\u0026lt;Widget\u0026gt;() ); 参考 https://blog.csdn.net/Dong_HFUT/article/details/125111586 33：泛型lambda的完美转发版本 对auto\u0026amp;\u0026amp;类型的形参使用decltype，以std::forward之\n泛型lambda（C++14）：可以使用auto声明形参（即闭包类中的operator()可以使用模板实现） 1 2 3 4 5 6 7 auto f = [] (auto x) {return func(x);} // 闭包类中的operator()的大致实现：auto形参实际上是模板类型推导 class SomeCompilerGeneratedClassName{ public: template \u0026lt;typename T\u0026gt; auto operator() (T x) const {return func(x);} } 泛型lambda的完美转发版本： 1 2 3 4 5 6 7 8 9 auto f = [] (auto\u0026amp;\u0026amp; param) {return func( std::forward\u0026lt;decltype(param)\u0026gt;(param) );} // 闭包类中的operator()的大致实现 class SomeCompilerGeneratedClassName{ public: template \u0026lt;typename T\u0026gt; auto operator() (T\u0026amp;\u0026amp; param) const { return func( std::forward\u0026lt;decltype(param)\u0026gt;(param) ); } }; auto fs = [] (auto\u0026amp;\u0026amp;... params) {return func( std::forward\u0026lt;decltype(params)\u0026gt;(params)... );} // 变长参数版本 参考 https://blog.csdn.net/Dong_HFUT/article/details/125116613 34：优先选用lambda表达式，而非std::bind 对于C++11，除了个别边缘case，lambda比std::bind更有优势；C++14，lambda完全可以替代std::bind\nlambda可读性更强，更容易理解 使用std::bind需要保持参数位置，同时需要了解其实现机制 std::bind需要保持参数位置，因此使用时需要查看原来函数的声明，才能知道占位符对应的参数类型和参数含义；但是lambda形参列表很明确 std::bind默认将参数拷贝到绑定对象内部（可以使用std::ref指定传引用），但是lambda可以明确指出值捕获还是引用捕获 std::bind绑定对象的函数调用使用了完美转发机制，但是lambda可以从形参列表中清晰看出传值还是传引用 1 2 3 4 5 6 7 Widget w; Logger logger; auto f = [w, \u0026amp;logger] (CompressLevel level) { return compress(w, level, logger); } // 捕获对象：w值捕获，logger引用捕获；形参：level传值 auto g = std::bind(compress, w, std::placeholders::_1, std::ref(logger)); // 需要对应参数顺序 // 绑定对象：w值绑定（复制），logger引用绑定；形参：level使用完美转发机制 std::bind参数绑定和对象调用不是一个时间，因此可能出现逻辑错误（见参考） lambda灵活性更强 如果std::bind绑定的函数存在重载版本，则编译器无法确定使用哪个版本的重载函数 1 2 3 4 5 6 7 void func(int a); void func(int a, int b); auto f = [] (int b) { return func(0, b); } using funcType = void(int, int); auto bnd = std::bind(static_cast\u0026lt;funcType\u0026gt;(func), 0, std::placeholders::_1) lambda可以内联 因为std::bind中绑定的是函数指针，需要在运行时才能确定；但是lambda中包含函数体，可以进行内联 使用std::bind的两个场景：在C++11中 使用std::bind间接实现移动捕获（[[ch06-lambda表达式#32：使用初始化捕获将对象移入闭包|C++14支持移动捕获]]） 使用std::bind绑定参数的完美转发机制，间接多态函数对象（[[ch06-lambda表达式#33：泛型lambda的完美转发版本|C++14支持泛型lambda]]） 1 2 3 4 5 6 7 8 auto f = [callableObject] (const auto\u0026amp; param) { callableObject(param); }; class CallableObject{ public: template \u0026lt;typename T\u0026gt; void operator() (const T\u0026amp; param); }; auto g = std::bind(CallableObject(), std::placeholders::_1); // 将占位符参数完美转发到可调用对象的调用运算符中 参考 https://blog.csdn.net/Dong_HFUT/article/details/125130410 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但","title":"[Effective Modern Cpp Notes] Ch06 Lambda表达式"},{"content":"23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为const对象经过std::move会返回一个const右值引用，而一般函数重载的移动版本形参都是非const的右值引用，无法匹配 std::move不移动对象，而且也不保证对象一定被移动，仅仅返回对象的右值引用 1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; // C++14 decltype(auto) move(T\u0026amp;\u0026amp; param) { using ReturnType = remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); } std::forward：实现完美转发（保持对象的左值性或右值性） 通常情况下，形参总是左值，即使其类型是右值引用 std::move和std::forward只是进行类型转换，在运行时不做任何事 参考 https://blog.csdn.net/Dong_HFUT/article/details/123765869 24：区分万能引用和右值引用 万能引用和右值引用只是形式上类似，但这是两个概念\n万能引用：形式为T\u0026amp;\u0026amp;或auto\u0026amp;\u0026amp;，并且存在类型推导 函数模板参数：template \u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; param); auto类型推导：auto\u0026amp;\u0026amp; val = myVal; 1 auto myFunc = [] (auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... params) {/* do something */} 右值引用 带const（不是纯粹的T\u0026amp;\u0026amp;形式）：template \u0026lt;typename T\u0026gt; void func(const T\u0026amp;\u0026amp; param); 形式是T\u0026amp;\u0026amp;，但是不存在类型推导：比如vector的push_back，但是emplace_back中参数是万能引用 1 2 3 4 5 6 7 8 template \u0026lt;typename T, typename Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector{ public: void push_back(T\u0026amp;\u0026amp; x); // 调用push_back时，类型T已知 template \u0026lt;typename... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // 参数包args的类型Args独立于T，存在类型推导，这里是万能引用 } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123773321 25：针对右值引用实施std::move，针对万能引用实施std::forward 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Widget{ // 以例子来说明 public: Widget(Widget\u0026amp;\u0026amp; rhs): name(std::move(rhs.name)), sp(std::move(rhs.sp)) {} // 形参为右值引用，将形参（左值）进行移动 template \u0026lt;typename T\u0026gt; void setName(T\u0026amp;\u0026amp; newName){ // 形参为万能引用，保持形参的左值性或右值性 cout\u0026lt;\u0026lt;\u0026#34;set new name:\u0026#34;\u0026lt;\u0026lt;newName\u0026lt;\u0026lt;endl; name = std::forward\u0026lt;T\u0026gt;(newName); // 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候 } Widget operator+(Widget\u0026amp;\u0026amp; lhs, Widget\u0026amp;\u0026amp; rhs){ lhs.name += rhs.name; return std::move(lhs); } template \u0026lt;typename T\u0026gt; T doNothing(T\u0026amp;\u0026amp; t) { return std::forward\u0026lt;T\u0026gt;(t); } private: string name; shared_ptr\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp; }; 重载setName不是一个好的设计 可能效率低：如果传入字面量，即使匹配到右值版本的函数，形参仍然会作为临时对象 如果有多个参数，需要重载$2^N$种，如果使用参数包，则无法实现 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候 如果函数中将形参进行处理，然后返回 传值返回：如果形参是右值引用（比如Widget operator+成员函数），使用move返回；如果形参是万能引用（比如doNothing成员函数），使用forward返回 如果返回值是函数中的局部变量，则编译器有特定的优化：RVO 返回值优化RVO（Return Value Optimization）：减少函数返回时产生临时对象，进而消除部分拷贝或移动操作 1 2 3 4 5 6 7 8 9 10 11 12 // 原来 Widget func() { return Widget(); } // 有一次默认构造，一次拷贝构造 Widget w = func(); // 再加上一次拷贝构造 // 使用RVO优化，上面过程相当于： void func(Widget\u0026amp; w) { w.Widget::Widget(); } // Widget w在外面分配空间，直接传入func中进行构造，因此只需要一次（默认）构造 // NRVO(Named Return Value Optimization)原理类似 Widget func() { Widget w; return w; // 返回对象已经具名 } 使用前提：局部对象的类型和返回值类型相同，而且局部对象就是返回值 限制场景： 返回std::move()：默认构造+移动构造 进行赋值而非初始化Widget w; w = func();：默认构造+func中的默认构造和拷贝构造 不同的分支条件下，返回不同的局部对象 参考 https://blog.csdn.net/Dong_HFUT/article/details/123946594 26：避免依万能引用类型进行重载 原因：函数匹配规则 如果模板实例化出的函数和普通重载函数都精确匹配，则优先选择普通重载函数，其次选择模板函数实例化出来的精确版本 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Person{ public: explicit Person(int idx): _name(nameFromIdx(idx)) {} template \u0026lt;typename T\u0026gt; // 对Person(int)的重载 explicit Person(T\u0026amp;\u0026amp; name): _name(std::forward\u0026lt;T\u0026gt;(name)) {} private: std::string _name; }; short id = 1; Person p1(id); // 会调用模板实例化的版本，而非进行类型转换调用普通版本 const Person p2(id); // 这个情况极其容易混淆， Person q2(p2); // 会调用生成的拷贝构造函数（因为其实参为const Person\u0026amp;） Person q1(p1); // 会调用模板实例化的版本，而非调用生成的拷贝构造函数 // 尤其当Person作为基类，派生类在构造函数中初始化基类部分时 class SpecialPerson: public Person{ public: SpecialPerson(const SpecialPerson\u0026amp; rhs): Person(rhs) {} SpecialPerson(SpecialPerson\u0026amp;\u0026amp; rhs): Person(std::move(rhs)) {} // 这两个构造函数均使用基类Person构造函数的完美转发版本， } // 对万能引用参数的函数进行重载，不是一个好的设计 27：熟悉依万能引用类型进行重载的替代方案 放弃重载，使用不同的函数名\n但是对于构造函数就无能为力 普通函数形参为const type\u0026amp;类型\n因此传入const实参，会优先使用原来的普通版本，而非重载的万能引用版本 将形参从引用类型换成值类型：当知道肯定要复制形参时，考虑按值传递\n1 2 3 4 5 6 7 class Person{ public: explicit Person(std::string name): _name(std::move(name)) {} explicit Person(int idx): name(nameFromIdx(idx)) {} private: std::string _name; } 使用Tag分发：使用Tag对参数进行区分，进而分发到不同的函数实现\n背景：如果想使用完美转发，就必须要使用万能引用 例子： 1 2 3 4 5 6 7 8 9 10 // 两个函数实现的版本 template \u0026lt;typename T\u0026gt; void logAndAddImpl(T\u0026amp;\u0026amp; name, std::false_type) {} template \u0026lt;typename T\u0026gt; void logAndAddImpl(int idx, std::true_type) {} // 使用Tag对参数进行区分 template \u0026lt;typename T\u0026gt; void logAndAdd(T\u0026amp;\u0026amp; name) { logAndAddImpl( std::forward\u0026lt;T\u0026gt;(name), std::is_integral\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;() ); // 或者C++14：std::is_integral\u0026lt;typename std::remove_reference_t\u0026lt;T\u0026gt; } 如果传入true or false，到运行时才能决定 在编译阶段进行模板匹配，std::is_integral在编译阶段就可以判断类型是否为整型 约束接受万能引用的模板：std::enable_if判断\n背景：构造函数无法使用Tag分发 例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;type_traits\u0026gt; class Person{ public: explicit Person(int idx): _name(nameFromIdx(idx)) {} template\u0026lt;typename T, typename = std::enable_if_t\u0026lt; !std::is_base_of_v\u0026lt;Person, std::decay_t\u0026lt;T\u0026gt;\u0026gt; \u0026amp;\u0026amp; !std::is_integral_v\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt; \u0026gt; \u0026gt; // 当类型T不为Person或者其派生类，抑或T不为int型时，才会选择这个的重载版本，使用万能引用进行重载并实现完美转发 explicit Person(T\u0026amp;\u0026amp; name): _name(std::forward\u0026lt;T\u0026gt;(name)) { static_assert( std::is_constructible(std::string, T)::value, \u0026#34;Parameter name can\u0026#39;t be used to construct a std::string\u0026#34; ); // 验证类型为std::string的对象能否被类型为T的对象构造 } private: std::string _name; }; std::enable_if\u0026lt;condition\u0026gt;::type：只有满足条件的模板才会使用（C++14std::enable_if_t） std::is_same\u0026lt;T1, T2\u0026gt;::value（C++17std::is_same_v） std::is_base_of\u0026lt;T1, T2\u0026gt;::value：如果T2继承于T1，则为true；且std::is_base_of\u0026lt;T, T\u0026gt;::value==true（C++17std::is_base_of_v） std::decay\u0026lt;T\u0026gt;::type的类型与T的类型相同，忽略了引用、const、volatile（C++14std::decay_t） 权衡\n前三种方案都需要对需要调用的函数形参逐一指定其类型，后两种方案使用万能引用实现了完美转发 虽然完美转发效率更高（避免创建临时对象），但是某些对象无法实现完美转发，并且使用完美转发并编译报错时，报错信息的可读性很差 std::is_constructible可以在编译期测试一个类型的对象能否被另一个不同类型的对象（或者多个不同类型的多个对象）构造，因此可以用来验证转发函数的万能引用参数是否合法 参考\nSFINAE技术 https://blog.csdn.net/Dong_HFUT/article/details/124227488 28：理解引用折叠 几种引用折叠的应用场景： 万能引用的实例化：在模板类型推导时，可能出现“引用的引用”的情况，此时需要用到引用折叠 std::forward完美转发： 1 2 3 4 template \u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param){ return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } auto类型推导，decltype类型推导 typedef类型别名 参考 https://blog.csdn.net/Dong_HFUT/article/details/124517043 29：假定移动操作不存在、成本高、未使用 几种移动语义不可用、不高效的情况： 没有移动操作：编译器只有在没有用户自定义拷贝操作和析构函数时，才自动生成移动操作 移动未能更快： std:array 一般STL中容器的对象都分配在堆上，对象中有指向堆上内存的指针，因此移动操作只需要进行指针的更新、源对象的指针置空即可 但是std::array中内容分配在栈上（栈上的数组），移动操作等于复制操作 std::string std::string针对小对象有一个优化SSO（Small String Optimization），小对象直接存储在栈上而非堆上，省去动态内存分配 移动不可用：移动操作没有标记为noexcept 如果移动操作没有标记为noexcept，即使是适合使用移动操作的场景，编译器也会使用复制操作替代 源对象是左值：只有右值可以作为移动操作的源（左值可以用，但是很容易造成空悬问题） 参考 https://blog.csdn.net/Dong_HFUT/article/details/124577258 30：熟悉完美转发的失败情形 完美转发的含义：不仅转发对象，而且转发其特征（左值、右值、const、volatile） 完美转发的失败情形 列表初始化 1 2 3 4 5 6 7 8 void f(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {} template \u0026lt;typename T\u0026gt; void fwd(T\u0026amp;\u0026amp; param) {} f({1,2,3}); // ok fwd({1,2,3}); // 编译报错：无法推断出T的类型 auto il = {1,2,3}; fwd(il); // T=initializer_list\u0026lt;int\u0026gt; 0或NULL作为空指针 0或NULL会被推导为int型而非空指针类型，因此完美转发后得到的类型是int，但是形参是指针类型 仅仅声明整型的静态常量数据成员 1 2 3 4 5 class Widget{ public: static cosnt int cnst = 12; // 声明而非定义，不会分配实际的存储空间，而是常量传播（直接将用到cnst的地方替换为12） }; fwd(Widget::cnst); // 编译报错：找不到cnst的定义 只声明不会分配空间，因此无法取地址，也无法使用引用，不能使用完美转发 解决方法：在类外或是对应.cpp文件中添加定义：const int cnst = 12; 函数重载和函数模板 1 2 3 4 5 6 7 8 9 10 void f(int (*pf)(int)); int func(int a); int func(int a, int b); f(func); // ok fwd(func); // 模板类型推导失败：无法确定是哪个重载版本 // 解决方法： using FuncType = int (*)(int); fwd(static_cast\u0026lt;FuncType\u0026gt;(func)); // 但是万能引用和完美转发一般是针对任意类型的，这里限定了类型，语义与实现矛盾 位域：位域只是int类型的一部分，没有一个确切地址，也就无法引用 参考 https://blog.csdn.net/Dong_HFUT/article/details/124787082 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","summary":"23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为","title":"[Effective Modern Cpp Notes] Ch05 右值引用、移动语句和完美转发"},{"content":"18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋值是delete的），只能进行移动操作从而转移资源控制权 例外：可以从函数返回一个std::unique_ptr 1 2 3 4 5 std::unique_ptr\u0026lt;int\u0026gt; func(int x){ auto delInt = [\u0026amp;](int* p) { cout\u0026lt;\u0026lt;\u0026#34;My deleter\u0026#34;\u0026lt;\u0026lt;endl; delete p;} std::unique_ptr\u0026lt;int, decltype(delInt)\u0026gt; pInt(new int(x), delInt); return pInt; } 删除器是std::unique_ptr类型的一部分 在不定义删除器的情况下，std::unique_ptr内存占用和原始指针相同 如果自定义删除器，则std::unique_ptr内存占用会变大 std::unique_ptr可以指向数组，默认删除器为delete[]：std::unique_ptr\u0026lt;int[]\u0026gt; p(new int[5]{1,2,3,4,5}); 但是数组形式用到的场合很少，尽量使用STL std::unique_ptr可以直接隐式转换为std::shared_ptr 典型应用：针对继承体系，作为工厂函数的返回值类型 1 2 3 4 5 6 7 8 9 10 11 class Animal {}; class Dog: public Animal {}; class Cat: public Animal {}; template \u0026lt;typename... Ts\u0026gt; auto makeAnimal(AnimalType type, Ts\u0026amp;\u0026amp;... AnimalInfo){ // C++14中函数返回值可以写为auto，因此unique_ptr的删除器可以放在函数内部，否则显式写出返回类型时需要知道删除器类型，因此删除器只能写在函数外部 auto delAnimal = [](AnimalType* ptr) { makeMyLog(ptr); delete ptr; } std::unique_ptr\u0026lt;Animal, decltype(delAnimal)\u0026gt; up(nullptr, delAnimal); if(type == Dog) up.reset(new Dog(std::forward\u0026lt;Ts\u0026gt;(AnimalInfo)...)); // 参数是万能引用，这里进行完美转发 if(type == Cat) up.reset(new Cat(std::forward\u0026lt;Ts\u0026gt;(AnimalInfo)...)); // 使用reset使得指针独占资源的所有权，不能直接将原始指针赋值给智能指针 return up; // 返回unique_ptr } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123465058 19：使用std::shared_ptr管理具备共享所有权的资源 std::shared_ptr可以拷贝，通过引用计数来管理资源的生命周期 std::shared_ptr内存模型 一个std::shared_ptr大小通常为普通指针的两倍：一个指针指向资源，另一个指针指向控制块 控制块中通过原子操作维护引用计数，保存deleter（因此deleter不属于std::shared_ptr类型的一部分），保存弱计数等 std::shared_ptr的使用： 使用std::make_shared、std::unique_ptr、原始指针创建std::shared_ptr，会为资源创建一个控制块 如果资源有多个控制块，就会被多次析构，因此尽量避免使用原始指针构造std::shared_ptr 使用std::shared_ptr或std::weak_ptr创建一个std::shared_ptr，不会创建一个新的控制块 this的陷阱： 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal{ virtual void eat(){ eatList.emplace_back(this); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(this)); } }; struct Cat: public Animal{}; struct Dog: public Animai{}; shared_ptr\u0026lt;Animal\u0026gt; myCat(new Cat); myCat-\u0026gt;eat(); // 针对同一个对象创建了两个控制块 解决方法一：使类继承自std::enable_shared_from_this，类内部使用shared_from_this方法，搜索当前对象的控制块，如果有就不用创建控制块了，如果没有则抛出异常，因此适合于当前对象已经创建过控制块的情况 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal: public std::enable_shared_from_this\u0026lt;Animal\u0026gt;{ virtual void eat(){ eatList.emplace_back(shared_from_this()); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(shared_from_this())); } }; struct Cat: public Animal{}; struct Dog: public Animai{}; shared_ptr\u0026lt;Animal\u0026gt; myCat(new Cat); myCat-\u0026gt;eat(); 解决方法二：见127页，代码是自己实现的，有误 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal: public std::enable_shared_from_this\u0026lt;Animal\u0026gt;{ public: template \u0026lt;typename... Ts\u0026gt; static shared_ptr\u0026lt;Animal\u0026gt; create(Ts\u0026amp;\u0026amp;... params) { return shared_ptr\u0026lt;Animal\u0026gt;(Animal(std::foward\u0026lt;Ts\u0026gt;(params)...)); } virtual void eat(){ eatList.emplace_back(shared_from_this()); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(shared_from_this())); } private: Animal() {} // 构造函数 }; struct Cat: public Animal{}; struct Dog: public Animai{}; 参考 https://blog.csdn.net/Dong_HFUT/article/details/123599599 20：对于类似std::shared_ptr但是可能空悬的指针使用std::weak_ptr std::weak_ptr通常视为std::shared_ptr的辅助工具，通过std::shared_ptr构造std::weak_ptr std::weak_ptr不会影响对象的引用计数 但是std::weak_ptr没有解引用操作，必须调用lock转换为std::shared_ptr来访问对象 例子：if(shared_ptr\u0026lt;int\u0026gt; p = wp.lock()\u0026gt; cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;endl; 典型应用： 避免shared_ptr循环引用：将其中一个shared_ptr改为weak_ptr 1 2 3 4 5 6 7 8 9 10 struct A{ std::shared_ptr\u0026lt;B\u0026gt; pb; // std::weak_ptr\u0026lt;B\u0026gt; pb; }; struct B{ std::shared_ptr\u0026lt;A\u0026gt; pa; }; std::shared_ptr\u0026lt;A\u0026gt; pa = std::make_shared\u0026lt;A\u0026gt;(); std::shared_ptr\u0026lt;B\u0026gt; pb = std::make_shared\u0026lt;B\u0026gt;(); pa-\u0026gt;pb = pb; // pb和pa-\u0026gt;pb同时指向同一个对象B，引用计数为2 pb-\u0026gt;pa = pa; 带缓存的工厂方法 1 2 3 4 5 6 7 8 9 std::shared_ptr\u0026lt;const Widget\u0026gt; fastLoadWidget(WidgetID id){ static std::unordered_map\u0026lt;WidgetID, weak_ptr\u0026lt;const Widget\u0026gt;\u0026gt; cache; std::shared_ptr\u0026lt;const Widget\u0026gt; widgetPtr = cache[id].lock(); if(!widgetPtr){ // 缓存中没有 widgetPtr = loadWidget(id); // 调用原始工厂方法创建，并加入到缓存中 cache[id] = widgetPtr; } return widgetPtr; } 观察者设计模式：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的std::weak_ptr，以便在使用之前确认它是否空悬。 参考： https://blog.csdn.net/Dong_HFUT/article/details/123612236 21：优先选用std::make_unqiue和std::make_shared，而非直接使用new make函数可以传入任意集合的参数，然后完美转发给构造函数，并动态创建一个对象，返回智能指针 支持auto 避免异常：将[[ch03-资源管理#17：以独立语句将new的对象置入智能指针| effective C++ item17：以独立语句将new的对象置入智能指针]]改进为使用make函数 1 2 3 4 5 6 7 void func(shared_ptr\u0026lt;Widget\u0026gt; sp, int priority); void func(shared_ptr\u0026lt;Widget\u0026gt;(new Widget), priority); // 可能由于异常导致内存泄露 void func(make_shared\u0026lt;Widget\u0026gt;(), priority); // 不会由于异常导致内存泄露 // 如果需要自定义删除器，并且又可以避免异常 shared_ptr\u0026lt;Widget\u0026gt; sp(new Widget, myDeleter); func(std::move(sp), priority); // 直接传递一个右值，避免了修改引用计数 效率更高：make函数只需要申请一次内存（同时存储对象和控制块），但是使用shared_ptr\u0026lt;Widget\u0026gt;(new Widget)需要申请两次内存（一次对象，一次控制块） make函数的缺点： 无法自定义deleter 语义歧义：比如使用()和{}初始化vector代表不同的方式，make函数可以完美转发()，不支持完美转发{} 1 2 3 4 auto sp1 = make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(2,3); // {3,3}; shared_ptr\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp2(new vector{1,2,3,4,5}); auto initList = {1,2,3,4,5}; auto sp3 = make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(initList); // 不支持：make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;({1,2,3,4,5}); 不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的operator new和operator delete被设计成用来分配和释放能精确容纳该类大小的内存块，但std::allocate_shared所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。 若存在非常大的对象和比相应的std::shared_ptr生存期更久的std::weak_ptr，不建议使用 make 函数，会导致对象的析构和内存的释放之间产生延迟 如果只申请一块内存（make函数），如果后来shared_ptr的引用计数为0，但是weak_ptr的引用计数不为0时，对象销毁会被延长，只有当weak_ptr的引用计数为0时，控制块才被释放 如果使用new的话，可以立即销毁对象 参考 https://blog.csdn.net/Dong_HFUT/article/details/123622543 22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中 PImpl技术（Pointer to Implementation，编译防火墙）：将类的实现放在另一个单独的类中，并通过不透明的指针进行访问。因此可以有效减少编译依赖。 原理：一个只声明但是不定义的类型是不完整类型，声明指向它的指针是可以通过编译的 常见错误： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // in \u0026#34;widget.h\u0026#34; #include \u0026lt;memory\u0026gt; class Widget { public: Widget(); private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; //==================================================================================// // in \u0026#34;widget.cpp\u0026#34; #include \u0026#34;widget.h\u0026#34; #include \u0026lt;string\u0026gt; struct Widget::Impl { std::string name; }; Widget::Widget(): pImpl(std::make_unique\u0026lt;Impl\u0026gt;()){} //==================================================================================// // in \u0026#34;main.cpp\u0026#34; #include \u0026#34;widget.h\u0026#34; int main(){ Widget w; // 报错：/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete type ‘Widget::Impl’ return 0; } 报错原因：在析构Widget w时，此时看到的Impl是不完整类型 在编译widget.cpp时没有问题：g++ -c widget.cpp -o widget.o 在编译main.cpp时出问题：g++ -c main.cpp -o main.o 没有定义Widget的析构函数，因此使用自动生成的析构函数（默认是inline的） 本来如果声明了Widget的析构函数，编译时无法进行处理，后面链接时链接到定义，运行时才能析构pImpl（因为经过链接，此时也知道Impl是完整类型） 但是正因为自动生成的析构函数是inline的，编译时就可以展开，此时析构pImpl当然看到的Impl是不完整类型（还没有链接到widget.o） 使用说明 考虑到如上报错和[[ch03-转向现代C++#17：理解特殊成员函数的生成机制|item17：理解特殊成员函数的生成机制]]，因此最好将拷贝控制成员和析构函数自定义，且声明与实现分离（防止进行内联） 为了实现PImpl技术，使用unique_ptr是最合适的，因为pImpl指针独享Impl的所有权，如果使用shared_ptr则上述报错不会出现（因为删除器不属于类型的一部分，属于控制块，不会包含删除器的代码） 参考 https://blog.csdn.net/Dong_HFUT/article/details/123704824 https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp 实例 widget.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;memory\u0026gt; class Widget{ public: Widget(std::string s); Widget(const Widget\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs); Widget(Widget\u0026amp;\u0026amp; rhs); Widget\u0026amp; operator=(Widget\u0026amp;\u0026amp;); ~Widget(); std::string getName() const; private: // std::string _name; struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026#34;widget.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; struct Widget::Impl{ Impl(std::string name): _name(name) {}; std::string _name; std::string getName() const {return _name;} }; Widget::Widget(std::string s): pImpl(std::make_unique\u0026lt;Impl\u0026gt;(s)) {} Widget::~Widget() {} Widget::Widget(const Widget\u0026amp; rhs): pImpl(std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl)) {} Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs){ *pImpl = *rhs.pImpl; return *this; } Widget::Widget(Widget\u0026amp;\u0026amp; rhs) =default; Widget\u0026amp; Widget::operator=(Widget\u0026amp;\u0026amp; rhs) =default; std::string Widget::getName() const { return pImpl-\u0026gt;getName();} main.cpp 1 2 3 4 5 6 7 8 #include \u0026#34;widget.h\u0026#34; #include \u0026#34;iostream\u0026#34; int main(){ Widget w(\u0026#34;zhang\u0026#34;); std::cout\u0026lt;\u0026lt;w.getName()\u0026lt;\u0026lt;std::endl; return 0; } ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","summary":"18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋","title":"[Effective Modern Cpp Notes] Ch04 智能指针"},{"content":"07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限制 ()不能用于non-static成员的初始化 不能拷贝的对象不能使用()初始化 {}初始化的优点 禁止基本类型之间的隐式窄化类型转换：比如不能使用double初始化int型变量 避免了C++复杂的语法分析：C++\u0026rsquo;s most vexing parse 1 2 3 Widget w1(10); // 传入一个实参，构造出一个对象 Widget w2(); // 本来想调用无形参的构造函数构造一个对象，但是实际上声明了一个函数 Widget w3{}; // 调用无形参的构造函数，构造出一个对象 {}的缺陷 auto类型推导中使用{}进行初始化，则auto被推断为initializer_list\u0026lt;T\u0026gt; 会优先使用形参为initializer_list\u0026lt;T\u0026gt;的构造函数，即使其他的构造函数更加匹配 只有当{}中参数无法转换为initializer_list中类型时，编译器才匹配普通函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Widget{ public: Widget() {cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;\u0026lt;\u0026lt;endl;} Widget(int i, int d) {cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;\u0026lt;\u0026lt;endl;} Widget(int i, bool d) {cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;\u0026lt;\u0026lt;endl;} Widget(initializer_list\u0026lt;int\u0026gt; il) {cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;\u0026lt;\u0026lt;endl;} Widget(const Widget\u0026amp; w) {cout\u0026lt;\u0026lt;\u0026#34;copy ctor\u0026#34;\u0026lt;\u0026lt;endl;} Widget(Widget\u0026amp;\u0026amp; w) {cout\u0026lt;\u0026lt;\u0026#34;move copy ctor\u0026#34;\u0026lt;\u0026lt;endl;} operator int() const { cout\u0026lt;\u0026lt;\u0026#34;convert to int\u0026#34;\u0026lt;\u0026lt;endl; return 1; } }; Widget w1{1, true}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，即使Widget(int i, bool d)更加匹配 Widget w2{1, 1.0}; // 编译报错，本来调用Widget(initializer_list\u0026lt;int\u0026gt; il)，但是使用{}初始化禁止窄化类型转换（存在从double到int的转换） Widget w3{w1}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)（中间先将w1转为int），即使Widget(const Widget\u0026amp; w)更加匹配（如果w1无法转换为int，则调用该构造函数） Widget w4{std::move(w1)}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，即使Widget(Widget\u0026amp;\u0026amp; w)更加匹配 // 特殊情况： Widget w4{}; // 调用Widget()，而非调用Widget(initializer_list\u0026lt;int\u0026gt; il) Widget w5{{}}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，而非调用Widget() Widget w6({}); // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，而非调用Widget() 使用模板创建对象时，仔细考虑使用()还是{}进行初始化 标准库函数std::make_unique和std::make_shared也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。 1 2 3 4 5 6 7 8 9 template \u0026lt;typename T, typename... Ts\u0026gt; void f(Ts\u0026amp;\u0026amp;... params){ // 使用可变参数模板 T localVector1(std::forward\u0026lt;Ts\u0026gt;(params)...); T localVector2{std::forward\u0026lt;Ts\u0026gt;(params)...}; } f\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(3,4); // 推断出T=vector\u0026lt;int\u0026gt;, Ts=int // localVector1: 4,4,4 // localVector2: 3,4 参考 https://blog.csdn.net/Dong_HFUT/article/details/122811753 08：优先选用nullptr，而非0或NULL 字面量0是一个int，NULL的实现为0L，可以转换为int，bool，void* nullptr可以理解为任意类型的空指针 使得重载函数的调用明确 提高代码的清晰度 使用类型推导时，nullptr可以隐式转换为任意类型指针 参考 https://blog.csdn.net/Dong_HFUT/article/details/122891898 09：优先选用别名声明，而非typedef using别名的优点： 清晰，比typedef更容易理解 可以直接对模板起别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; using MyAllocList = std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; // 如果非要使用typedef，需要包装一层 template \u0026lt;typename T\u0026gt; struct MyAllocList{ typedef std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; type; }; template \u0026lt;typename T\u0026gt; class Widget{ MyAllocList\u0026lt;T\u0026gt; list1; // list1=std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;,此时MyAllocList一定是一个别名 typename MyAllocList\u0026lt;T\u0026gt;::type list2; // list2=MyAllocList\u0026lt;T\u0026gt;中的std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; // 需要使用typename显式说明MyAllocList\u0026lt;T\u0026gt;::type是一个类型，而非数据成员 } 应用：标准库的\u0026lt;type_traits\u0026gt;中提供了一整套用于类型转换的类模板 虽然C++11中仍然是使用typedef实现的，但是C++14中是使用using声明实现的 1 2 std::remove_const\u0026lt;T\u0026gt;::type // C++11中, 是一个内部包裹typedef的类模板，将T中的const属性移除 std::remove_const_t\u0026lt;T\u0026gt; // C++14中, 是一个类模板中typedef别名的别名，将T中的const属性移除 参考 https://blog.csdn.net/Dong_HFUT/article/details/122847510 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型 无作用域限制的枚举（unscoped enums，C++98） 有时使用可能简便一点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using UserInfo = std::tuple\u0026lt;std::string, std::string, std::size_t\u0026gt; //name, email,age enum UserInfoFields {uiName, uiEmail, uiAge}; UserInfo uInfo; auto email = std::get\u0026lt;1\u0026gt;(uInfo); // 位置1为email auto email = std::get\u0026lt;uiEmail\u0026gt;(uInfo); // 发生隐式类型转换 auto email = std::get\u0026lt;static_cast\u0026lt;std::size_t\u0026gt;(UserInfoFields::uiEmail)\u0026gt;(uInfo); // 冗余 // C++14下的辅助类:既想使用有作用限制的枚举，又不想过于啰嗦 template \u0026lt;typename E\u0026gt; constexpr auto toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); } auto email = std::get\u0026lt;toUType(UserInfoFields::uiEmail)\u0026gt;(uInfo); 有作用域限制的枚举（scoped enums，C++11） 减少名称污染 1 2 3 4 5 enum unscopedColor{black, white}; auto black = false; // 无作用域限制的枚举，因此枚举类型暴露在{}之外 enum class scopedColor {red, blue}; auto red = false; // 有作用域限制的枚举，枚举类型限制在{}之内，因此减少名称污染 有强类型 1 2 3 4 5 enum unscopedColor{black, white}; double d1 = black; // 无作用域限制的枚举，可以发生隐式类型转换 enum class scopedColor {red, blue}; double d2 = static_cast\u0026lt;double\u0026gt;(scopedColor::red); // 有作用域限制的枚举，不会发生隐式类型转换，类型转换需要显式说明 可以前向声明：只有在指定底层类型后，才能进行前向声明 1 2 enum unscopedColor: std::uint8_t; // 没有提供默认底层类型 enum class; //默认底层类型为int 参考 https://blog.csdn.net/Dong_HFUT/article/details/122914289 11：优先选用删除函数，而非private未定义函数 背景：编译期会自动生成某些函数，但是有时不需要这些函数； C++98的做法：声明为private的，且只声明不定义（effective C++中item6） 在private中声明但是不定义，使之在链接阶段因为没有定义而报错 在基类中声明为private的，会因为无法拷贝控制派生类中的基类部分，将报错从链接期提前到编译期 C++11的做法：在声明中标记为=delete 将删除的函数声明为public的，原因是编译器先检查访问权限，再检查delete状态。如果将删除的函数声明为private的，调用删除的函数时，可能报错原因提示是private的；但是更期望的更明确的含义是这些函数是删除的 =delete可以在任意函数中进行标记，不仅仅局限于成员函数 应用： 比如可以阻止某些形参的隐式类型转换 1 2 void func(int a); void func(double) =delete; // 因此禁止double和float两种参数的调用（C++总是倾向于将 float 转换为 double） 阻止某些模板类型的实例化 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; void func(T* ptr); template \u0026lt;\u0026gt; void func\u0026lt;void\u0026gt;(void* ptr) =delete; struct Widget{ template\u0026lt;typename T\u0026gt; void g(T* ptr); }; template\u0026lt;\u0026gt; void Widget::g\u0026lt;void\u0026gt;(void* ptr) = delete; // 成员模板函数在类外阻止某些类型的实例化 参考 https://blog.csdn.net/Dong_HFUT/article/details/123005509 12：给意在改写的函数添加override声明 重写override需要满足的条件 基类的重写函数必须是虚函数 基类和派生类的重写函数 函数名（析构函数除外）、形参类型、函数常量性完全相同 函数引用限定符完全相同（C++11，函数引用限定符：该成员函数可以被左值对象还是右值对象调用） 返回值类型、异常规格说明兼容 将重写的函数标记为override，如果不满足重写条件则报错 参考 https://blog.csdn.net/Dong_HFUT/article/details/123008755 13：优先选用const_iterator，而非iterator C++98在容器的成员函数中对const_iterator支持有限 C++11在容器的成员函数中支持const_iterator，但是只提供了非成员的begin和end 1 2 3 4 template \u0026lt;typename Container\u0026gt; // C++11实现cbegin的方法 auto cbegin(const Container\u0026amp; container) -\u0026gt; decltype(std::begin(container)){ // auto=const Container::iterator\u0026amp; return std::begin(container); } C++14提供了非成员的cbegin和cend 尽量使用非成员的cbegin和cend，因为某些数据结构（比如数组）没有成员函数cbegin和cend，非成员的cbegin和cend更加通用 1 2 3 4 5 6 7 template\u0026lt;typename C, typename V\u0026gt; void findAndInsert(C\u0026amp; container, const V\u0026amp; targetVal, const V\u0026amp; insertVal) { using std::cbegin; using std::cend; auto it = std::find(cbegin(container), cend(container), targetVal); container.insert(it, insertVal); } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123030976 14：只要函数不会抛出异常，就为其加上noexcept声明 noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。 相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。 noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。 大部分函数是异常中立的而不是 noexcept。 背景： C++98中异常规范的局限性：接口的实现一旦被修改，其异常规范可能也变化 因此C++11只需要指明接口是否可能抛出异常 优点：一个noexcept函数有更多编译优化的机会 不需要保持运行栈为解开的状态 不需要保证对象以构造顺序的逆序完成析构 应用：如果知道一个函数不会抛出异常，一定要加上noexcept noexcept属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略 默认noexcept函数：C++11内存释放函数和所有的析构函数都默认隐式地具备noexcept属性 析构函数未隐式地具备noexcept属性的唯一情况，就是所有类中有数据成员（包含递归的成员）的类型显式地将其析构函数声明为noexcept(false) 如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。 条件noexcept：一个函数是否为noexcept，取决于noexcept中的表达式是否为noexcept 只有被调用的低层次的函数是noexcept，高层次的调用方才是noexcept的 1 2 3 4 template \u0026lt;typename T1, typename T2\u0026gt; struct myPair{ void swap(myPair\u0026amp; p) noexcept( noexcept(swap(first, p.first)) \u0026amp;\u0026amp; noexcept(swap(second, p.second)) ); } 异常中立函数：本身不抛出异常，但是调用的函数可能抛出异常，因此不适合标记为noexcept 但是允许noexcept函数中调用没有noexcept保证的函数 通常只为宽松规约提供noexcept声明 宽松规约（wide contract，宽接口）：不带前提条件，被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为 狭隘规约（narrow contract，窄接口）：带前提条件，如果违反前提条件，则结果是未定义的 调用者来保证调用时满足前提条件 如果调用时违反前提条件，则抛出异常；如果定义为noexcept的，违反前提条件结果是未定义的；相较而言，找出抛出异常的原因相对简单一些 参考 https://blog.csdn.net/Dong_HFUT/article/details/123163671 15：只要有可能使用constexpr，就使用它 constexpr对象：具备const属性，并且在编译期（和链接期）可以确定其值 const对象不能保证在编译期确定其值 constexpr函数 含义： 如果所有传入 constexpr 函数的参数都能在编译时知道，则结果将在编译时计算出来。 如果传入 constexpr 函数的参数有任何一个不能在编译期知道，则结果在运行时计算出来 使用 C++11中，constexpr函数有且只能有一条return语句；C++14无此限制 constexpr 函数被限制只能接受和返回 literal 类型（字面量，非指针和引用，自定义类型也可能是字面量类型的） C++11中，如果成员函数修改了操作的对象，或者成员函数的返回值是void的，则该成员函数无法成为constexpr的；C++14无此限制 1 2 3 4 5 6 7 8 9 10 11 class Point{ public: constexpr Point(double xVal=0, double yVal=0) noexcept: x(xVal), y(yVal) {} constexpr double getX() const noexcept {return x;} constexpr double getY() const noexcept {return y;} constexpr void setX(double newX) noexcept { x = newX;} // C++14中，移除了两条限制，因此可以设置为constexpr的 constexpr void setY(double newY) noexcept { y = newY;} private: double x, y; }; constexprt Point p1(1.0, 2.0); 参考 https://blog.csdn.net/Dong_HFUT/article/details/123172189 16：保证const成员函数的线程安全性 const成员的好处：不会修改成员变量，而且可以区分重载（const对象和非const对象调用） 保证const成员函数的线程安全性 使用std::mutex，进入临界区锁对象获取互斥量，出临界区析构锁（释放互斥量） 使用std::atomic，但是只能同步单一变量或者内存单元 std::mutex和std::atomic都是move-only的 参考 https://blog.csdn.net/Dong_HFUT/article/details/123316263 17：理解特殊成员函数的生成机制 特殊成员函数（special member function）： 一般是public、inline和novirtual的 例外：如果基类中的析构函数是virtual的，派生类中的析构函数也是virtual的 拷贝构造和拷贝赋值是两个独立的操作 移动构造和移动赋值不是独立的操作，如果声明了其中一个，编译器会阻止生成另外一个 如果显式申明一个拷贝操作，则两个移动操作不会自动生成 三法则（The Rule of Three）：如果声明了{拷贝构造函数、拷贝赋值操作、析构函数}中任意一个，则应该声明所有这三个函数，因为往往意味着类要管理某些资源 因此，如果只声明了一个析构函数，编译器应该不会自动生成拷贝操作 但实际上编译器还是可能自动生成拷贝操作（历史遗留原因，以及C++11为了兼容历史代码） 因此，只有当类中没有声明析构函数、拷贝操作、移动操作，而且需要时，编译器才会生成移动操作 如果想让编译器自动生成相关函数（即使违背了这些限制），添加=default进行标记 C++11中对特殊成员函数的生成规则： 默认构造函数：同C++98 析构函数：本质同C++98，只是默认声明为noexcept 拷贝构造函数：运行期行为同C++98（memberwise 拷贝构造 non-static 成员变量） 如果类中声明了一个移动操作，则拷贝构造函数和拷贝赋值运算符被标记为=delete的 如果类中自定义拷贝赋值运算符或析构函数，可以生成拷贝构造函数，但是已经成为被废弃的方法 拷贝赋值运算符：规则同拷贝构造函数 移动构造函数和移动赋值运算符：仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成 特殊情况：成员模板函数不会抑制特殊成员函数的自动生成 1 2 3 4 5 class Widget{ public: template \u0026lt;typename T\u0026gt; Widget(const T \u0026amp;rhs); template \u0026lt;typename T\u0026gt; Widget\u0026amp; operator=(const T\u0026amp; rhs); }; // 编译器仍然会生成copy和move操作，即使可以实例化得到 参考 https://blog.csdn.net/Dong_HFUT/article/details/123433559 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c++/","summary":"07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限","title":"[Effective Modern Cpp Notes] Ch03 转向现代C++"},{"content":"05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写一长串类型名） 优点三：声明闭包类型（lambda表达式） C++11中lambda式返回值可以使用auto，C++14中lambda式形参也可以使用auto std::function通常比起auto更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐auto。 使用auto声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同 使用std::function声明的、存储着一个闭包的变量是std::function的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么std::function的构造函数就会分配堆上的内存来存储该闭包。 优点四：避免类型截断 优点五：避免类型不匹配 1 2 3 4 5 std::unordered_map\u0026lt;std::string, int\u0026gt; mp; for(auto\u0026amp; item: mp) { // auto=std::pair\u0026lt;const std::string,int\u0026gt; // 但是如果显式定义类型，很容易定义为std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; } 06：当auto推导的类型不符合要求时，使用带显式类型的初始化习惯用法 隐式的代理类型可能导致auto类型推导结果不符合预期，因此应该显式声明类型 代理类：模拟和拓展某些其他类型的行为，比如智能指针，比如std::vector\u0026lt;bool\u0026gt;::reference std::vector\u0026lt;bool\u0026gt;进行了特化，与一般std::vector不同： 一般对于vector\u0026lt;T\u0026gt;的operator []操作，返回类型为T\u0026amp;；但是对于vector\u0026lt;bool\u0026gt;的operator []操作，返回类型为vector\u0026lt;bool\u0026gt;::reference（因此可能发生到bool的隐式类型转换），这是因为标准库无法返回对bit的引用 vector\u0026lt;bool\u0026gt;::reference的实现中，可能有一个指向word的指针和一个对应的offset，很可能出现难以预料的错误 1 2 3 vector\u0026lt;bool\u0026gt; func(); auto flg = func()[0]; // func()返回一个临时的右值对象，flg是vector\u0026lt;bool\u0026gt;::reference类型，然后临时的右值对象被析构 // 因为vector\u0026lt;bool\u0026gt;::reference类型中可能有一个指针，再使用flg可能出现未定义的行为 表达式模板中，计算结果可能被解析为一棵语法解析树，而非直接返回计算结果，因此实际得到的结果类型（语法解析树）可能并非期望的类型 # C++元编程之表达式模板优化数组计算 总之，对(隐形)代理类的auto类型推导往往得到的不是预期的类型，因此要么显式声明类型，要么使用static_cast强转然后进行auto类型推导 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/","summary":"05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写","title":"[Effective Modern Cpp Notes] Ch02 Auto"},{"content":"01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特殊处理。 - 值传递形参的类型推导时，其 const 和 volatile 被忽略。 - 在模板类型推导时，数组或者函数类型被转换为指针类型，除非它们用来初始化引用。 背景：有时模板类型推导无法一下看出来T是什么类型 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // 比如实参可能是int, const int, const int\u0026amp; 类型T的推导不仅取决于expr的类型，也取决于ParamType的形式 情况一：ParamType是指针或引用，但不是万能引用 1 2 3 template \u0026lt;typename T\u0026gt; void f(T\u0026amp; param); template \u0026lt;typename T\u0026gt; void f(const T\u0026amp; param); template \u0026lt;typename T\u0026gt; void f(T* param); 情况二：ParamType是万能引用，因此可能发生引用折叠 1 template \u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); 情况三：ParamType不是指针，也不是引用，因此视为值传递（实参的const/volatile性质被忽略，因为值进行了复制，形参副本不影响原来的实参） 1 template \u0026lt;typename T\u0026gt; void f(T param); 特殊情况一：传入的实参为数组类型 如果模板是情况一：推导出T为数组类型（包含类型和元素数量） 1 2 3 template \u0026lt;typename T\u0026gt; void f(T\u0026amp; param); const char name[] = \u0026#34;zhang\u0026#34;; f(name); // 推导出T=const char[6], f(const char(\u0026amp;param)[6]) 应用：比如可以在编译阶段计算数组元素个数： 1 2 template \u0026lt;typename T, std::size_t N\u0026gt; constexpr std::size_t arraySize(T (\u0026amp;)[N]) noexcept {return N;} 如果模板是情况三：将数组名视为指针，因此T是指针类型 特殊情况二：传入的实参为函数类型 如果模板是情况一：推导出T为函数引用类型 如果模板是情况三：推导出T为函数指针类型 参考： https://blog.csdn.net/Dong_HFUT/article/details/122727237 02：理解auto类型推导 一般情况下，auto类型推导和模板类型推导完全相同；但是auto类型推导会假定使用{}的列表初始化表达式是一个std::initializer_list，但是模板类型推导不会 在函数返回值或lambda式形参中使用auto，意思是使用模板类型推导而非使用auto类型推导 背景：将一个变量赋值给auto类型变量，auto是什么类型 同[[ch01-类型推导#01：理解模板类型推导|01：理解模板类型推导]]中的总体原则：将实参赋值给形参 除了一个例外：使用{}进行列表初始化 auto类型推导： 1 2 auto x = {1, 2, 3}; // auto=std::initializer_list\u0026lt;int\u0026gt;,首先推导为std::initializer_list\u0026lt;T\u0026gt;，然后再推断类型T=int auto y{2}; // auto=int 模板类型推导：不能直接将{}的列表初始化表达式推导为T=std::initializer_list\u0026lt;type\u0026gt;， 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(T param); f({1, 2, 3}); // 报错：直接传入{}列表初始化的实参，模板类型推导失败 template \u0026lt;typename T\u0026gt; void g(std::initializer_list\u0026lt;T\u0026gt; initList); g({1, 2, 3}); // T=int 为什么两种行为不同的一个可能解释 1 2 3 template \u0026lt;typename T\u0026gt; void func(T\u0026amp; a, T\u0026amp; b); func(vector\u0026lt;int\u0026gt;{1,2,3}, {1,2,3}); // 左边推导出T=vector\u0026lt;int\u0026gt;, 右边如果推导出T=initializer_list\u0026lt;int\u0026gt;,则左右冲突 auto可以作为函数返回值类型、lambda式形参类型（C++14） 但是原理是模板类型推导，而非auto类型推导 参考 https://blog.csdn.net/Dong_HFUT/article/details/122740091 03：理解decltype 绝大多数情况下，decltype会得到变量或表达式的类型，而不进行修改 对于类型为T的左值表达式，除非该表达式只有一个名字，否则decltype总是返回T\u0026amp; C++14支持decltype(auto)：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导 背景：给定一个名字或表达式，decltype返回其类型：原来是值/左值/右值，返回值/左值/右值 体会auto类型推导和decltype类型推导的区别 auto类型推导：将变量rhs赋值给lhs，推导出lhs的类型 decltype类型推导：返回变量rhs的类型 使用场景： 声明一个函数模板，其返回值类型取决于参数类型 1 2 template \u0026lt;typename Container, typename Index\u0026gt; auto getItem(Container\u0026amp; c, Index i) -\u0026gt; decltpye(c[i]) { return c[i]; } // 返回类型是引用T\u0026amp; 如果返回值为auto，使用auto类型推导，返回类型将不是引用 1 2 template \u0026lt;typename Container, typename Index\u0026gt; auto getItem(Container\u0026amp; c, Index i) { return c[i]; } // 返回类型是T 可以同时使用auto和deltype：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导 1 2 template \u0026lt;typename Container, typename Index\u0026gt; decltype(auto) getItem(Container\u0026amp; c, Index i) { return c[i]; } // 返回类型是引用T\u0026amp; 优化与完善：为了传入右值的Container，使用万能引用，同时使用完美转发 1 2 template \u0026lt;typename Container, typename Index\u0026gt; decltype(auto) getItem(Container\u0026amp;\u0026amp; c, Index i) { return std::forward\u0026lt;Container\u0026gt;(c)[i]; } // C++14，或者C++11使用尾置返回类型 一般而言decltype返回的类型都比较直观，除了一种情况： 1 2 3 int x = 0; // decltype(x)=int // decltype((x))=int\u0026amp; 参考 https://blog.csdn.net/Dong_HFUT/article/details/122745518 https://zyfforlinux.blog.csdn.net/article/details/52658452 04：掌握查看类型推导结果的方法 在代码编辑阶段查看类型推导结果：IDE 在代码编译阶段查看类型推导结果：查看编译报错 在代码运行阶段查看类型推导结果： typeid：不同编译期实现不同，无法保证完全可靠，而且类型的引用、const、volatile等性质被忽略 Boost库的模板函数boost::typeindex::type_id_with_cvr 如果类型不包含引用、const、volatile等性质，则type_id_with_cvr与typeid返回相同 1 2 3 4 5 6 7 8 #include \u0026lt;boost/type_index.hpp\u0026gt; template \u0026lt;typename T\u0026gt; void f(const T\u0026amp; param){ using std::cout; using boost::typeindex::type_id_with_cvr; // c:const, v:volatile, r:reference cout\u0026lt;\u0026lt;type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; cout\u0026lt;\u0026lt;type_id_with_cvr\u0026lt;decltype(param)\u0026gt;().pretty_name()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/","summary":"01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特","title":"[Effective Modern Cpp Notes] Ch01 类型推导"},{"content":"49：了解new-handler的行为 new申请内存失败会抛出bad alloc的异常，此前会调用一个错误处理函数，此函数由std::set_new_handler()指定 set::set_new_handler() 接受一个错误处理函数，返回旧的错误处理函数 throw表示可能抛出的异常类型，参数为空表示不抛出任何异常 1 2 typedef void (*new_handler)(); // 无形参，返回值为void的函数指针 new_handler set_new_handler(new_handler f) throw(); 当new申请不到足够的内存时，会不断调用错误处理函数f，因此错误处理函数应该进行下面的处理之一： 提供更多可用的内存 向set_new_handler中传入一个新的错误处理函数 set_new_handler函数中传入一个空指针，因此内存分配失败时不进行处理，直接抛出异常 抛出bad_alloc的异常 不返回：调用std::abort或std::exit abort会设置程序非正常退出 exit会设置程序正常退出，当存在未处理异常时，会调用terminate，内部回调set::set_terminate设置的回调函数，默认会调用abort 类型相关错误处理 为不同的类分配对象时，使用不同的错误处理函数 重载set_new_handler和operator new，重载为static成员 可以写成模板 此处的模板参数T并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的currentHandler 这个做法用到了所谓的 CRTP（curious recurring template pattern，奇异递归模板模式），也常被用于静态多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template \u0026lt;typename T\u0026gt; class NewHandlerSupport { public: static std::new_handler set_new_handler(std::new_handler p) noexcept; static void* operator new(std::size_t size); ~NewHandlerSupport() {std::set_new_handler(currentHandler);} private: NewHandlerSupport(const NewHandlerSupport\u0026amp;); // 阻止拷贝构造 NewHandlerSupport\u0026amp; operator=(const NewHandlerSupport\u0026amp;); // 阻止拷贝复制 static std::new_handler currentHandler; }; template \u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::currentHandler = nullptr; template \u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_handler p) noexcept { std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; } template \u0026lt;typename T\u0026gt; void* NewHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) { NewHandlerSupport h(std::set_new_handler(currentHandler)); // 返回的函数指针初始化了一个对象h，在退出函数时，执行h的析构过程，即将原来的handle恢复 return ::operator new(size); } // 使用 class Widget: public NewHandlerSupport\u0026lt;Widget\u0026gt;{ ... }; new分配失败后，可能不会抛出异常，而是返回null，这种称为nothrow new 例子：new (std::nothrow) int[10]; nothrow new只能保证内存分配错误时不抛出异常，无法保证对象的构造函数不抛出异常 50： 了解new和delete的合理替换时机 为什么需要自定义operator new 检测使用错误：检测多次delete，检测越界 提高效率：手动维护更适合应用场景的存储策略 比如针对特定类型，增加分配和归还的速度 比如将相关对象集成到簇中（即尽量分配到一个内存页上） 收集使用的统计信息 其他原因：比如安全性（将申请到的内存初始化为0），字节对齐等 51： 编写new和delete时需固守常规 operator new需要无限循环地获取资源，如果没能获取则调用\u0026quot;new handler\u0026quot;，不存在\u0026quot;new handler\u0026quot;时应该抛出异常；\noperator new应该处理size == 0的情况；\noperator delete应该兼容空指针；\noperator new/delete作为成员函数应该处理size \u0026gt; sizeof(Base)的情况（因为继承的存在）。\n外部（非成员函数的）operator new：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void* operator new(std::size_t size) throw(std::bad_alloc){ if(size == 0) size = 1; // size=0时，返回合法的指针就说明成功分配了内存 while(true){ void *p = malloc(size); if(p) return p; // 申请失败，获得new handler，多线程需要加锁 new_handler h = set_new_handler(0); set_new_handler(h); // auto h = get_new_handler(); // C++11方式 if(h) (*h)(); // new-handler应该实现item49中描述的五种行为之一，否则，此处陷入死循环 else throw bad_alloc(); } } 成员operator new\n如果operator new是针对基类的，也就是说operator new是针对大小为sizeof(Base)的内存进行优化的 一般来说派生类不应该使用基类的operator new，因为派生类对象大小与基类对象大小一般不同 1 2 3 4 5 6 7 8 9 10 11 12 class Base{ public: static void* operator new(std::size_t size); }; void* Base::operator new(std::size_t size) { if(size != sizeof(Base)) // sizeof(Base)永远不会为0（至少为1），因为空对象至少会插入一个char return ::operator new(size); // 使用全局的operator new ... } class Derived: public Base { ... }; operator new[]与operator new有相同的参数和返回值，只需要分配一块原始内存 delete\ndelete 惯例：delete一个空指针是安全的 外部operator delete\n1 2 3 4 void operator delete(void* rawMemory) noexcept { if (rawMemory == 0) return; // 释放 rawMemory 所指的内存 } 成员operator delete 如果基类的析构函数不是虚函数，则size大小为静态类型的大小； 比如Base* p = new Derived; delete p;中，很可能派生类大小大于基类大小，因此存在内存泄露 否则size为动态类型的大小 1 2 3 4 5 6 7 8 void Base::operator delete(void* rawMemory, std::size_t size) noexcept { if (rawMemory == 0) return; if (size != sizeof(Base)) { ::operator delete(rawMemory); // 转交给标准的 operator delete 进行处理 return; } // 释放 rawMemory 所指的内存 } 52： 写了placement new也要写`palcement delete placement new：广义上指拥有额外参数的operator new 背景： 在使用new创建对象时，往往进行了两个函数的调用：一个是operator new，进行内存分配；一个是对象的构造函数 如果构造失败，此时对象没有被创建，对象无法被析构，且此时还没有拿到分配内存的地址 因此需要运行时系统进行delete，运行时系统需要知道使用的是哪一种operator new，因此调用对应的operator delete 如果没有对应的operator delete函数，则运行时系统什么都不做，导致内存泄露 当定义了placement new时，同时也要定义对应的placement delete 用户直接调用delete时，运行时系统不会将其解释为placement delete，因此还需要定义一个正常的delete 1 2 3 4 5 6 class Widget{ public: static void* operator new(std::size_t size, std::ostream\u0026amp; log) throw(std::bad_alloc); static void operator delete(void *mem, std::ostream\u0026amp; log); static void operator delete(void *mem) throw(); }; 名称隐藏：类中的名称会隐藏类外的名称，子类的名称会隐藏父类的名称 三种全局new 1 2 3 void* operator(std::size_t) throw(std::bad_alloc); // normal new void* operator(std::size_t, void*) noexcept; // placement new void* operator(std::size_t, const std::nothrow_t\u0026amp;) noexcept; // nothrow new 最佳实践： 将全局版本new在一个基类中进行重载，内部调用全局new进行实现 然后在自定义类Widget中，public继承，并使用using声明使得三种new和三种delete对Widget可见，因此同时Widget可以定义自己版本的placement new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class StandardNewDeleteForms { public: // normal new/delete static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); } // placement new/delete static void* operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); } static void operator delete(void *pMemory, void *ptr) throw() { return ::operator delete(pMemory, ptr); } // nothrow new/delete static void* operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void *pMemory, const std::nothrow_t\u0026amp;) throw() { ::operator delete(pMemory); } }; class Widget: public StandardNewDeleteForms { public: using StandardNewDeleteForms::operator new; using StandardNewDeleteForms::operator delete; static void* operator new(std::size_t size, std::ostream\u0026amp; log) throw(std::bad_alloc); // 自定义 placement new static void operator delete(void *pMemory, std::ostream\u0026amp; logStream) throw(); // 对应的 placement delete }; ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch08-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/","summary":"49：了解new-handler的行为 new申请内存失败会抛出bad alloc的异常，此前会调用一个错误处理函数，此函数由std::set_","title":"[Effective Cpp Notes] Ch08 定制new和delete"},{"content":"41： 了解隐式接口与编译期多态 面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态\n如果函数的形参是普通类： 普通类的显式接口由函数签名（函数名、形参类型、返回值类型）表征，运行时多态由虚函数实现 在函数进行编译时，就可以知道该普通类有哪些接口 如果函数的形参是模板类型： 模板类型的隐式接口由表达式的合法性表征（即该模板类型应该支持函数中形参调用的方法），编译器多态由模板初始化和重载函数的解析实现 在函数进行编译时，无法知道模板类型有哪些接口，因此视为鸭子类型（即传入对象支持函数中调用的方法即可） 在编译函数时当然无法确定模板类型，但是当传入实参后，内部如果调用了实参未定义的函数，同样会在编译期报错而非运行期 参考： https://www.zhihu.com/question/423699453 42： 了解typename的双重意义 在模板声明中，使用class与typename完全相同 在模板内部，typename还可以用来显式指明【嵌套从属类型名称】 背景：比如编译器无法在模板内部判断T::mem是一个static成员（默认），还是一个类型 嵌套从属类型名称：T::mem是一个依赖于模板参数T的类型 例子：模板内部typename T::age myAge = 25; typename还可以用来显式指明【嵌套从属类型名称】，可以出现在模板内部、函数形参列表，但是不可以出现在【类派生列表】和【构造函数中成员初始化列表】中 当类型名称过于复杂时，可以使用类型别名 参考 https://harttle.land/2015/09/09/effective-cpp-42.html 43： 使用模板化基类中的成员函数 背景：如果基类是一个模板类，派生类进行继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Buff {}; class RedBuff: public Buff {}; class BlueBuff: public Buff {}; template \u0026lt;typename T\u0026gt; // 基类 class Container { /* 假设有成员函数func() */}; //template \u0026lt;\u0026gt; // 全特化基类 //class Container\u0026lt;Buff*\u0026gt; { /* 假设没有成员函数func() */ }; // template \u0026lt;typename T=Buff*\u0026gt; // 使用默认模板实参，同全特化基类 // class Container\u0026lt;T\u0026gt; { /* 假设没有成员函数func() */ } template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { func(); } // 这里编译报错 }; 对于模板化基类，可能有特化版本，且其中可能有不同的接口 对于派生类而言，也无法确定类型T，因此C++规定派生类不在模板化基类中查找继承而来的接口 解决方法：向编译器承诺所有的特化版本都遵循模板化基类的接口（或者说使用非特化版本的模板化基类中的接口） 使用this显式指出访问基类的成员函数 1 2 3 4 5 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { this-\u0026gt;func(); } // this指针可以访问所有成员函数 }; 使用using声明 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: using Container\u0026lt;T\u0026gt;::func; // 告诉编译器，func在模板化基类中 void test() { func(); } }; 使用作用域运算符::明确指出，不推荐使用，因为如果func是虚函数，使用这种方法不会产生多态 1 2 3 4 5 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { Container\u0026lt;T\u0026gt;::func(); } // 明确指出 }; 44： 将与参数无关的代码抽离模板 背景：代码膨胀 模板提供的是编译期多态，不同的类型参数会生成不同的模板 比如一个模板类接受一个类型参数T与一个非类型参数N，大部分成员都使用类型参数T，只有极少部分成员使用非类型参数N 如果使用相同的类型type、但是不同的非类型参数n进行实例化，生成的代码中大部分都相同，只有极少部分不同 抽取公共代码： 模板中生成的冗余代码是隐式的，因为模板只有一份，生成不同实例后才可能产生冗余 比如可以将与参数无关的代码（成员函数，数据成员）放入基类中，然后private继承 参考 https://harttle.land/2015/09/12/effective-cpp-44.html 45： 运用成员函数模板接受所有兼容类型 背景：假如类型参数T存在继承关系，但是模板实例化后是完全不同的两个类 比如有一个继承体系，基类Base，派生类Derived 指向派生类的指针可以转换为指向基类的指针：Base* p = new Derived(); 但是指向派生类的智能指针无法转换为指向基类的智能指针： shared_ptr\u0026lt;Base*\u0026gt; sp = make_shared\u0026lt;Derived*\u0026gt;(new Derived()); 重载构造函数 接受同一模板的其他实例的构造函数称为通用构造函数 兼容类型检查：将MySmartPtr\u0026lt;U\u0026gt;转换为MySmartPtr\u0026lt;T\u0026gt;，前提是类型U可以转换为类型T 如果没有声明拷贝构造函数，编译器会自己生成一个，而非使用通用构造函数去进行成员模板实例化 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; class MySmartPtr{ public: MyShartPtr(T* p): ptr(p) {} template \u0026lt;typename U\u0026gt; MySmartPtr(const MySmartPtr\u0026lt;U\u0026gt;\u0026amp; other): ptr(other.get()) {}; // 带类型兼容检查的通用构造函数，可以实现隐式类型转换（因为不带explicit） T* get() const {return ptr;} private: T *ptr; }; MySmartPtr\u0026lt;Derived*\u0026gt; dp(new Derived()); // 隐式类型转换 MySmartPtr\u0026lt;Base*\u0026gt; bp = MySmartPtr\u0026lt;Derived*\u0026gt;(new Derived()); // T=Base*, U=Derived* 参考 https://harttle.land/2015/09/13/effective-cpp-45.html 46：需要类型转换时请将模板定义为非成员函数 背景： 1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; class Rational {}; template \u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {} Rational\u0026lt;int\u0026gt; oneHalf(1,2); Rational\u0026lt;int\u0026gt; result = oneHalf * 2; // Error 模板函数的调用过程： 首先推导出类型T，将函数进行实例化：此时无法从2推导得出类型T 在调用时，有的参数可能需要隐式类型转换 解决方法：将模板函数定义为类的友元，因此类模板实例化后类型T已知 如果仅仅是声明，编译器不会对友元函数进行实例化，因此需要进行定义 定义在类内部的函数是inline的，可以在类外部定义一个辅助函数（也是模板函数，但是不需要隐式类型转换） 1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename T\u0026gt; class Rational; template \u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; func(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {} template \u0026lt;typename T\u0026gt; class Rational{ public: friend Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs){ func(lhs, rhs); // 可以推导出类型T，而且不需要进行隐式类型转换 } } 47： 请使用traits classes表现类型信息 使用Traits的特点： 可以同时支持自定义类型和基础类型 在编译期就获取信息 C++中的Traits类可以在编译期提供类型信息，是通过Traits模板及其特化来实现的 C++标准库中提供了不同的Traits：iterator_traits,char_traits,numeric_limits等（以iterator_traits为例）\n背景：容器与算法通过迭代器联系在一起，算法中可能需要知道迭代器的类型、迭代器中元素的类型，由此有不同的处理方法 比如算法advance可以让一个迭代器移动n步（负数则反向移动） 迭代器有五种：其中随机访问迭代器可以直接使用+=操作 C++提供了五个类标识迭代器类型：input_iterator_tag，output_iterator_tag，forward_iterator_tag，bidirectional_iterator_tag，random_access_iterator_tag 传入的参数也可能是基本类型的指针 1 2 3 4 5 6 7 8 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ // 判断迭代器类型 if(iter is random access iterator) iter += d; else ... // 判断迭代器中元素类型 if(iter.value_type is MyVector) cout\u0026lt;\u0026lt;\u0026#34;MyVector\u0026#34;\u0026lt;\u0026lt;endl; } 分析： 如果IterT是类类型，因此可以在类中携带数据成员，表示迭代器类型和元素类型 但是IterT也可能是基本类型的指针类型，无法在其中携带信息 Traits技法：使用Traits可以通过一个模板类间接获取IterT的相关信息 1 2 template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits; Traits是C++中一种编程惯例，允许在编译期得到类型的信息 traits是一个用来携带信息的很小的类，需要实现两个部分： traits中的类型可能是用户自定义的类型， 自定义类型中需要实现相应的迭代器，对具体的类型信息起一个通用的别名 traits中包装相应的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; class MyVector{ // 自定义类 public: class iterator{ // 自定义类中的迭代器 public: using value_type = T; using iterator_category = my_random_access_iterator_tag; }; }; // iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器） template \u0026lt;typename IterT\u0026gt; struct iterator_traits{ // IterT是类类型 using iterator_category = typename IterT::iterator_category; using value_type = typename IterT::value_type; }; traits中的类型可能是基本数据类型，遵循相同的名称，包装一下相应的信息 1 2 3 4 5 template \u0026lt;typename IterT\u0026gt; struct iterator_traits\u0026lt;IterT*\u0026gt;{ // 特化版本：IterT是基本类型，IterT是基本类型的指针 using iterator_category = my_random_access_iterator_tag; // 指针可以使用+=操作，因此视为随机访问迭代器 using value_type = IterT; }; 使用 不好的写法：使用typeid在运行时判断类型 但是IterT类型在编译期就可以确定，对象iter的类型需要在运行时确定 更严重的问题：静态类型检查（编译期必须确保所有源码都有效，即使是不会执行的源码） ^826df6 比如即使迭代器不是my_random_access_iterator_tag类型，编译期也会进入if语句测试该迭代器是否支持+=运算，不支持的话编译报错 1 2 3 4 5 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ if( typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(my_random_access_iterator_tag) ) iter += d; } 推荐实现方法：根据不同的类型创建不同的重载方法（worker），然后在一个master函数中调用，依据traits类型进行重载调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ // 将IterT中迭代器类型和元素类型萃取出来 std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category).name()\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::value_type).name()\u0026lt;\u0026lt;std::endl; // 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性 // std::cout\u0026lt;\u0026lt;typeid(IterT::iterator_category).name()\u0026lt;\u0026lt;std::endl; doAdvance(iter, d, typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); // 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数 } // 随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_random_access_iterator_tag){ iter += d; } // 前向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_forward_iterator_tag){ assert(d \u0026gt;= 0 \u0026amp;\u0026amp; \u0026#34;d must be not less then 0\u0026#34;); while(d--) ++iter; } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;cassert\u0026gt; // using namespace std; struct my_random_access_iterator_tag { // my_random_access_iterator_tag() { std::cout\u0026lt;\u0026lt;\u0026#34;my_random_access_iterator_tag ctor\u0026#34;\u0026lt;\u0026lt;std::endl; } }; struct my_forward_iterator_tag{ // my_forward_iterator_tag() {std::cout\u0026lt;\u0026lt;\u0026#34;my_forward_iterator_tag\u0026#34;\u0026lt;\u0026lt;std::endl;} }; template \u0026lt;typename T\u0026gt; class MyVector{ // 自定义类 public: class iterator{ // 自定义类中的迭代器 public: using value_type = T; using iterator_category = my_random_access_iterator_tag; }; }; // iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器） // 输入：使用类类型的迭代器或指针类型进行实例化 // 输出：萃取出元素类型和迭代器类型 template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits{ // IterT是类类型 using iterator_category = typename IterT::iterator_category; using value_type = typename IterT::value_type; }; template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits\u0026lt;IterT*\u0026gt;{ // 特化版本：IterT是基本类型，IterT是基本类型的指针 using iterator_category = my_random_access_iterator_tag; // 指针可以使用+=操作，因此视为随机访问迭代器 using value_type = IterT; }; // std双向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag){ if(d \u0026gt; 0) while(d--) ++iter; else while(++d) --iter; } // std随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag){ iter += d; } // 自定义随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_random_access_iterator_tag){ iter += d; } // 自定义前向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_forward_iterator_tag){ assert(d \u0026gt;= 0 \u0026amp;\u0026amp; \u0026#34;d must be not less then 0\u0026#34;); while(d--) ++iter; } template \u0026lt;typename IterT, typename DistT\u0026gt; void myAdvance(IterT\u0026amp; iter, DistT d){ // 将IterT中迭代器类型和元素类型萃取出来 std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category).name()\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::value_type).name()\u0026lt;\u0026lt;std::endl; // 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性 // std::cout\u0026lt;\u0026lt;typeid(IterT::iterator_category).name()\u0026lt;\u0026lt;std::endl; // std::cout\u0026lt;\u0026lt; (typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::bidirectional_iterator_tag)) \u0026lt;\u0026lt;std::endl; // 不好的写法： // 静态类型检查，即使iter不是随机访问迭代器，也会进入if语句块内进行检查 // if( typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag) ) // iter += d; doAdvance(iter, d, typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); // 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数 } int main(){ int a[10]; for(int i = 0; i \u0026lt; 10; ++i) a[i] = i+1; int* p = \u0026amp;a[0]; myAdvance(p, 2); std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; std::list\u0026lt;int\u0026gt; lst{1,2,3,4,5,6,7,8,9,10}; std::list\u0026lt;int\u0026gt;::iterator it = lst.begin(); myAdvance(it, 2); std::cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;std::endl; return 0; } 48： 认识模板元编程 模板元编程（template metaprogramming，TMP）：编写模板，执行于编译期，生成具象化的代码 优点：可以将很多工作从运行期转移到编译期 一些错误可以提前发现 运行时更高效：可执行文件体积小，运行期短，内存需求少 避免了[[ch07-模板与泛型编程#^826df6|静态类型检查]]的问题 缺点：编译时间变长 模板元编程 图灵完备 循环由递归实现 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch07-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","summary":"41： 了解隐式接口与编译期多态 面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态 如果函数的形参是普通","title":"[Effective Cpp Notes] Ch07 模板与泛型编程"},{"content":"32：确定你的public继承构造出is-a关系 public继承的意思是，子类是一种特殊的父类（is-a关系） 子类必须涵盖父类每一个特点，必须无条件继承父类所有特性和接口 否则没有is-a关系，不应该使用public继承 因为很多时候凭生活经验判断，可能会错误判断为具有is-a关系，但是子类可能没有父类的某个特性 程序设计没有银弹 33：避免覆盖继承而来的名称 背景：父类中有多个重载的虚函数（同名），子类只重写了其中一个，会导致子类中父类的其他重载函数不可见 根本原因：如果子类重写了父类的重载函数的一部分，在进行名字查找中，可以在相应的静态类型（子类）中查找到名字，但是类型无法匹配 避免方法： 对于父类的重载方法，子类要么全部重写，要么一个都不重写 使用using声明 使用转交函数（forwarding function）？ 34：区分接口继承与实现继承 public继承可以分为函数接口继承和函数实现继承 基类中声明纯虚函数，派生类只继承其接口，且派生类需要提供实现 从代码层面提醒派生类主动实现其接口，即使纯虚函数在基类中也可以有实现（派生类也需要显式指明需要使用基类中的实现） 基类中声明虚函数，派生类继承其接口和缺省实现 基类中声明普通函数，派生类继承其接口和实现（好的编程习惯是不对子类方法进行重写） 35：考虑virtual函数以外的其他选择 通常面向多态的做法： 将接口设置为virtual的 通过Non-Virtual Interface(NVI)来实现template method模式 将接口Func的真正实现函数onFunc设置为private virtual的 基类中的private virtual方法，通过public继承到派生类，派生类可以进行重写 将接口Func设置为public non-virtual的，在Func中调用onFunc non-virtual的接口Func就称为virtual onFunc的wrapper 优点：在接口Func中调用onFunc前后，可以前置和后置的工作 缺点：在某些场景的继承体系中，virtual函数必须调用基类的版本，因此virtual函数必须是protected甚至public的，此时无法使用NVI strategy模式 基于Function Pointers的strategy模式 直接在构造函数中传入一个函数指针，用于实现多态 进一步的，可以基于C++11的std::function来实现strategy模式，在构造函数中传入一个可调用对象 古典的strategy模式：将函数指针替换为类指针，使用该类中的成员函数 优点：同一种类型可以使用不同的方法进行计算，而且可以在运行期变更使用的函数 缺点：函数指针只能访问public成员，否则只能弱化封装性，将外部函数声明为友元 36：绝不重写继承而来的non-virtual函数 从语法上看 虚函数执行的是动态绑定，非虚函数执行的是静态绑定 如果有多态调用的需求，设置为虚函数 从设计上看 public继承意味着一种is-a关系，子类是一种特殊的父类，不变性（父类的共性）凌驾于特异性（子类的个性）之上 重写public继承而来的non-virtual表示子类修改了父类的特性，违背了is-a关系，造成了设计上的矛盾 37：绝不重写继承而来的(虚函数的)缺省参数值 虚函数执行的是动态绑定，但是缺省参数值是静态绑定 因此可能执行的是动态类型版本的虚函数，但是缺省参数值是静态类型版本虚函数的，没有使用动态类型版本的缺省参数值，极易引起误会 缺省参数值采用静态绑定是为了提高运行时效率，这样可以在编译期将参数确定，而非得到运行时 解决方法： 如果使用虚函数，则采用相同的缺省参数值 使用Non-Virtual Interface(NVI)代替虚函数 将接口Func设置为public non-virtual的（因此不期望被重写），并带有缺省参数，因此不管怎么继承，缺省参数值都是相同的 将接口Func的实现逻辑onFunc设置为private virtual的，Func中将缺省参数传递给onFunc，调用动态版本的虚函数 38：通过复合构造出has-a关系或“根据某物实现出” 复合：一个类作为另一个类的数据成员 当复合发生在应用域内的对象之间时，表现出has-a的关系 比如Person类中有一个Address类 当复合发生在实现域内的对象之间时，表现出“根据某物实现出”的关系 比如使用List类模拟实现出一个Set类 39： 明智而审慎地使用private继承 private继承的特点： 如果派生类private继承自基类，则从派生类无法转换到基类 但是如果派生类public继承自基类，则派生类可以slice（切掉）转换为基类 private继承的意义：“根据某物实现出” 仅仅是为了让派生类使用基类中的某些方法，派生类与基类没有直接意义上的联系 private继承的使用：当需要进行“根据某物实现出”的时候 能用复合，就不要用private：绝大多数private继承的场合都可以使用“public继承+复合”进行代替 使用private继承： 比如想在Widget的派生类中，不定义OnTick方法，即使使用private继承，在Widget的派生类中仍然可以重新定义OnTick方法（类似NVI中方法） 同时Widget编译时必须依赖Timer 1 2 3 4 5 6 7 8 9 10 // 使用private继承 class Timer{ public: virtual void OnTick() const; }; class Widget: private Timer{ private: virtual void OnTick() const; // override } // Widget的派生类中仍有OnTick方法 使用复合： 在Widget的派生类中，可以没有OnTick方法（同C++11对成员函数使用final） 可以将WidgetTimer定义移出Widget，从而Widget编译时不需要Timer 1 2 3 4 5 6 7 8 9 10 11 12 class Timer{ public: virtual void OnTick() const; }; class Widget{ private: class WidgetTimer: public Timer{ public: virtual void OnTick() const; }; WidgetTimer timer; }; 使用private继承的情况：空白基类最优化（Empty Base Optimization，EBO） 40： 明智而审慎地使用多重继承 多重继承中可能遇到歧义调用，需要指明调用哪个基类中的接口 即使同名接口一个在基类中是public的，一个是private的（不会被调用），也会发生歧义 因为C++首先会找到最佳匹配函数，之后才会验证其可用性，如果两个同名的函数匹配程度相同，则发生二义性 遇到菱形继承时，使用虚继承，且尽量少的在虚基类中携带数据 多重继承的使用场景：public继承自某个抽象基类，private继承自某个协助实现的基类 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch06-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/","summary":"32：确定你的public继承构造出is-a关系 public继承的意思是，子类是一种特殊的父类（is-a关系） 子类必须涵盖父类每一个特点，必","title":"[Effective Cpp Notes] Ch06 继承与面向对象设计"},{"content":"26：尽可能延后变量定义式的出现时间 原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分 原因二：直接构造的效率高于默认构造+赋值 原因三：变量可能在循环中使用，变量定义在循环内部而非循环前面，可以避免将变量的作用域扩大；除非对循环部分的性能有要求。 27：尽量少做转型动作 三种风格的转型： C语言风格：(T)expression 函数风格：T(expression) C++风格： const_cast\u0026lt;T\u0026gt;(expression)：去除const属性 dynamic_cast\u0026lt;T\u0026gt;(exprssion)：将指向为基类的指针转型为指向派生类的指针，可能耗费重大运行成本 尽量少使用 reinterpret_cast\u0026lt;T\u0026gt;(expression) static_cast\u0026lt;T\u0026gt;(expression)：最常用 28：避免返回handles指向对象内部成分 handles：引用、指针、迭代器 避免返回指向内部对象的handles，返回一个成员变量的副本 增加可封装性 帮助const成员函数的行为像一个const 将发生”dangling handles“的可能性降到最低（当临时对象析构后，也就无法通过handle获取对象内部的成员） 29：为“异常安全”而努力是值得的 异常安全的含义：当异常被抛出时 不泄露资源：使用RAII 不发生数据败坏 异常安全的函数提供三种不同级别的保证： 基本承诺：不发生数据败坏，但是不保证程序状态 强烈保证：程序状态不变（即程序回复到”调用函数之前“的状态） 通过RAII和调换代码顺序实现 或者通过copy and swap实现：创建副本资源并进行操作，所有操作完成后，使用一个不会抛出异常的swap将副本与当前资源进行交换 不抛掷承诺：总能完成功能，作用域内置类型上的所有操作都提供nothrow承诺 强烈保证有时无法实现 异常安全保证具有木桶效应 30：透彻了解内联的里里外外 inline最初只是针对编译器的优化建议，而非强制；是否内联由优化等级所控制，与是否内联无关\n声明： 隐式声明：将函数定义与类内部（但不是一种好的编程风格） 显示声明：inline 内联函数通常被置于头文件中，因为内联大部分情况下时编译期行为 inline必须放在函数定义前 从实现上看，inline放在函数声明前不起作用 从编程风格看，应该严格区分声明与定义，而且用户不需要、也没有必要知道该函数是否内联 inline只是对编译器的一个申请，不是强制命令 31：将文件间的编译依存关系降到最低 pimpl idiom（pimpl：pointer to implementation）设计思想： 原来main class包含类的具体实现逻辑 现在将main class中具体实现逻辑，放到一个实现类Impl中，在private中添加一个指向Impl的指针 因此main class只是提供接口，实现类Impl负责实现接口，”类的接口与实现分离“ 背景：即使只是改动类的实现，而不改变类的接口，这样所有包含该类的源码都要重新编译 根本原因在于，编译器在编译期必须知道对象的大小，如果不知道类的定义，就无法为对象分配内存 方法一：提供句柄类，用”声明的依存性“替换”定义的依存性“ 原来：假设1000个文件依赖于Person.h，这1000个文件都要重新编译链接 1 2 3 4 5 6 7 8 // Person.h class Person{ public: std::string name() const; private: std::string mName; } // 假设在Person.cpp中，略微修改了std::string Person::name()的实现，1000个文件需要全部重新编译 现在：只需要修改PersonImpl的具体实现，重新编译这一个文件即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Person.h class PersonImpl; // PersonImpl声明 class Person{ public: std::string name() const; private: PersonImpl *pImpl; } // Person.cpp #include \u0026#34;Person.h\u0026#34; #include \u0026#34;PersonImpl.h\u0026#34; std::string Person::name(){ return pImpl-\u0026gt;name(); // 调用实现类中同名函数 } // PersonImpl.h class PersonImpl{ // PersonImpl与Person有相同的public函数，且Person的private数据成员移动到了PersonImpl的private部分 public: std::string name() const; private: std::string mName; } // PersonImpl.cpp #include \u0026#34;PersonImpl.h\u0026#34; std::string PersonImpl::name() {return mName;} 方法二：将句柄类定义为抽象类 基类中定义一个工厂方法，返回动态类型为派生类，静态类型为基类的指针 因此修改派生类中的方法的实现逻辑，不会影响到基类，”类的接口与实现分离“ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Person.h class Person{ public: Person(); virtual std::string name() const; static std::shared\u0026lt;Person\u0026gt; create(const std::string\u0026amp; name); virtual ~Person(); }; // Person.cpp #include \u0026#34;Person.h\u0026#34; #include \u0026#34;RealPerson.h\u0026#34; std::shared\u0026lt;Person\u0026gt; Person::create(const std::string\u0026amp; name){ return std::shared\u0026lt;Person\u0026gt;(new RealPerson(name)) } // RealPerson.h class RealPerson: public Person{ public: RealPerson(std::string\u0026amp; name): mName(name) {}; virtual std::string name() const; virtual ~RealPerson(); private: std::string mName; } 参考 https://www.zhihu.com/question/52832178/answer/192499529 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch05-%E5%AE%9E%E7%8E%B0/","summary":"26：尽可能延后变量定义式的出现时间 原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分 原因二：直接构造的效率高于默认构造","title":"[Effective Cpp Notes] Ch05 实现"},{"content":"18：让接口容易被正确使用，不易被误用 函数接口传参，使用者可能理解错误或不小心传错 将函数参数封装为新的类型，比如封装新的年月日类，而非直接传入数字 限制类型内可以进行的操作 比如添加const限制，比如item3 尽量使自定义类型和内置类型的行为保持一致 消除使用者的资源管理责任 比如直接返回一个智能指针，而非返回一个raw指针 19：设计class犹如设计type 设计类时，考虑的问题：\n如何创建以销毁：如何实现构造函数和析构函数 初始化与赋值的区别：如何实现构造函数和赋值操作符 类对象传值：如何实现拷贝构造函数 成员类型的合法值：在构造函数和赋值操作中进行检查 继承关系的约束：基类的相关虚函数、成员函数是否需要被声明为virtual 是否允许由别的类转换而来：如何写转换构造函数 哪些操作符和函数是合理的 哪些操作符和函数应该拒绝 成员给哪些用户使用：成员的访问控制权限 新类型的未声明接口是什么 是否有必要将类一般化为类模板 这个新类型是否真的需要 20：传参时，尽量传常量引用而非传值 优点： 减少一次对象的复制 避免对象切割（比如形参是基类，实参是派生类），同时实现多态 使用传值的情况：内置类型，STL迭代器，函数对象 21：函数返回值尽量不要为引用 禁止在函数中返回一个指向局部变量的指针或引用 不要在函数中返回一个动态分配的对象 不要在可能多次调用的函数中返回一个局部静态变量 错误返回引用的例子： 返回栈空间中局部变量的引用：函数返回后，栈上相应对象被销毁，因此未定义 返回堆空间中局部变量的引用：虽然函数返回后不会释放对象，但是函数返回赋值的变量占有了堆空间的资源，而且极易容易忘记释放（因为一般也基本不会考虑对返回值进行delete），造成内存泄露 返回静态变量的引用：当多次调用该函数返回静态变量的引用时，静态变量只有一个，例子 C++11中可以使用移动语义，减少拷贝带来的消耗 22：将成员变量声明为private 将成员变量声明为public的缺点： 缺乏语法一致性：访问public成员变量，可以直接访问或者调用成员函数 对成员变量处理缺少准确控制：将成员变量设置为private的，可以提供setter/getter函数来控制其读写权限 不利于封装：在成员变量发生变化时，可以在相关函数中通知其他变量，从而进行相应修改 23：宁以non-member、non-friend替换member函数 功能颗粒度较高的函数设置为类外的函数，而非封装为public成员函数\n背景：public成员函数可分为两类： 功能颗粒度较低的函数：public/protected成员函数，内部直接访问private成员 功能颗粒度较高的函数：public/protected成员函数，内部由若干个public成员函数集成而来 尽量将功能颗粒度较高的函数封装为类外的函数： 优化类的封装性：如果封装为public函数，本来希望该函数只是public函数的集成，但是这样没法在代码层面体现出来 允许我们从更多维度组织代码结构，提供更大的包裹弹性：比如将不同public成员函数封装为不同功能的外部函数 优化编译依赖关系：比如不同的public成员函数可以封装为不同功能的外部函数，这些外部函数分别放在不同文件中，但是属于同一个命名空间中；这样使用时，需要哪个功能，就只需要包含该文件即可 24：若所有参数皆需要类型转换，请为此采用non-member函数 如果希望运算符的任意操作数可以发生隐式类型转换，则应该将运算符重载为非成员函数（比如友元）\n背景：运算符可以重载，重载为成员函数呢，还是重载为非成员函数呢？ 规定：如果运算符是成员函数，则它的第一个运算对象不会发生隐式类型转换 因为编译器根据第一个运算对象的类型，确定调用的运算符是属于哪一类的 比如：z = x * y等价于z = x.operator*(y)，x不会发生隐式类型转换 25：考虑写出一个不抛出异常的swap函数 如果Widge是一个类，可以在std命名空间中实现std::swap\u0026lt;T\u0026gt;的Widge全特化版本，同时在Widge中实现类内的swap函数以修改private成员的值 1 2 3 4 5 6 7 8 9 10 11 class Widget{ public: void swap(Widget\u0026amp; other){ // member swap using std::swap; // default swap // 调用std::swap进行private成员的处理 } } namespace std{ template\u0026lt;\u0026gt; // std::swap特例化版本 void swap\u0026lt;Widge\u0026gt; (Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b);} } 如果Widge是一个类模板 不能偏特例化一个函数模板 1 2 3 4 namespace std{ template\u0026lt;typename T\u0026gt; // non-member swap void swap\u0026lt;Widget\u0026lt;T\u0026gt;\u0026gt; (Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} // 编译报错 } 但是可以偏特例化一个类模板，添加一个重载版本 但是不要在std命名空间中添加新东西 1 2 3 4 namespace std{ template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} } 解决方法：置于一个新的命名空间中 1 2 3 4 5 6 7 namespace WidgetStuff{ template\u0026lt;typename T\u0026gt; class Widget{ ... }; template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} } 因此，如果想使得Widget专属版swap在尽可能多的语境下被调用，需要 在Widget中提供一个public swap函数（不可抛出异常），内部调用std::swap 同时可能需要同时实现两个版本： Widget所在命名空间WidgetStuff中，实现一个nom-member swap，内部调用Widget::swap 如果Widget是一个类而非类模板，在std中特化std::swap，内部调用Widget::swap C++11之后，std::swap改用std::move实现，所以几乎不存在性能缺陷 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch04-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/","summary":"18：让接口容易被正确使用，不易被误用 函数接口传参，使用者可能理解错误或不小心传错 将函数参数封装为新的类型，比如封装新的年月日类，而非直接传","title":"[Effective Cpp Notes] Ch04 设计与声明"},{"content":"13：以对象管理资源 资源获取即初始化（RAII）：使用析构函数确保资源被释放 复制时使用移动语义，移交资源的所有权 背景：使用动态内存分配时，很容易忘记delete，尤其是程序在中间退出（比如if判断后return） RAII（Resource Acquisition Is Initialization）资源获取即初始化： 资源的有效期与持有资源的对象的生命周期严格绑定（即获取资源的时候要通过构造函数初始化） 对象独占资源 即让编译器在每个退出的分支上，对象都进行析构，从而释放资源 使用模板更加方便 移交所有权 背景：如果两个指针同时指向一个资源，会析构两遍；因此RAII类独占资源（类似unique_ptr） 在RAII类中，将拷贝相关的函数设置为=delete，RAII无法进行拷贝 因此只能通过移动构造函数使用std::move进行移交所有权 如何把RAII类作为函数的参数 值传递：各位caller，我不要ownership了，请拿走 非const引用传递：拿不拿走都行，提前商量好（不推荐） const引用传递：可以拿走用一下，但是ownership还是我的 右值引用：同第二条，无法确定caller是否拿走了ownership C++98与C++11 C++98中std::auto_ptr类似于C++11中std::unique_ptr，但是std::unique_ptr不允许所有权被转移 C++98中std::tr1::shared_ptr类似于C++11中std::shared_ptr，weak_ptr只是拥有资源的使用权而非所有权，因此不占用引用计数，可以解决环状引用的问题 梳理：RAII作为一种管理资源的方式（或思想），早期使用auto_ptr作为解决方案，C++11之后使用unique_ptr和move语义作为解决方案 参考： 现代C++学习—— 什么是RAII 14：在资源管理类中小心copying行为 复制RAII对象必须一并处理资源的copy行为\ncopy行为的不同情况： 大部分情况下，对RAII对象的复制操作本身就不合法 对底层资源使用引用计数法（shared_ptr） 复制底层资源（行为像值，进行深拷贝） 转移资源所有权（unique_ptr） 15：在资源管理类中提供对原始资源的访问 将RAII对象转换为对资源的直接访问 通过显示转换：提供一个get()函数返回智能指针内部的原始指针 通过隐式转换 像使用原始指针一样使用智能指针，比如智能指针一样可以使用-\u0026gt;访问成员 直接访问原始指针：在RAII类内实现返回原始指针的类型转换运算符 16：成对使用new和delete时要采取相同形式 new一个对象，使用delete释放；new一个数组，使用delete []进行释放 delete []表示知道释放的是数组，读取数组元素数量，从而多次调用析构函数 尽量避免对数组使用typedef，此时在delete时很容易出现混淆：用delete还是delete[]，可以的话可以使用std::vector等容器 17：以独立语句将new的对象置入智能指针 背景：编译器可能对单一语句中的执行顺序进行重新调整 1 2 3 4 5 6 7 8 9 10 int priority() {} void func(std::shared_ptr\u0026lt;MyResource\u0026gt; sp, int priority) {} func(std::shared_ptr\u0026lt;MyResource\u0026gt;(new MyResource), priority()); /* 该语句的执行顺序可能是： MyResource* tmp_ptr = new MyResource; int priority = priority(); std::shared_ptr\u0026lt;MyResource\u0026gt; sp = std::shared_ptr\u0026lt;MyResource\u0026gt;(tmp_ptr); */ 如果int priority = priority();执行失败，则tmp_ptr指向的临时资源无法被释放，发生内存泄漏 根本原因是：资源被创建和资源被转换成资源管理对象有时间差，中间可能有干扰 解决方法：以独立语句将new的对象置于智能指针中，因为编译器无法对跨语句的操作进行调整 1 2 std::shared_ptr\u0026lt;MyResource\u0026gt; sp(new MyResource); func(sp, priority()); ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch03-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","summary":"13：以对象管理资源 资源获取即初始化（RAII）：使用析构函数确保资源被释放 复制时使用移动语义，移交资源的所有权 背景：使用动态内存分配时，很","title":"[Effective Cpp Notes] Ch03 资源管理"},{"content":"05：了解C++默默编写并调用了哪些函数 如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成 有时编译器不会进行合成，因为一些操作非法 1 2 3 4 class MyClass {}; MyClass m1; // 生成默认构造函数和析构函数 MyClass m2(m1); // 生成复制构造函数 m2 = m1; // 生成赋值构造运算符 默认构造函数和析构函数 作用：调用{基类和non-static成员变量}的构造函数和析构函数 当自定义构造函数后，编译器就不会自动生成构造函数 生成的析构函数是non-virtual的，除非基类的析构函数是virtual的 复制构造函数 赋值构造运算符 自动生成赋值构造运算符的条件是，相关操作必须合法 比如成员变量是const或引用，则不能进行赋值 比如基类中赋值构造运算符是private的，则派生类中无法调用父类相应的赋值构造运算符对父类成员进行赋值 06：若不想使用编译器自动生成的函数，就该明确拒绝 在声明中将拷贝控制成员标记为=delete，将不会自动生成该拷贝控制成员\n背景：有时不希望类具有拷贝等行为（语义要求） 三种方法：将不需要自动生成的拷贝控制成员 在private中进行定义 虽然类外部无法访问，但不是绝对安全，可以在成员函数和友元中使用 写为空函数体，使其在链接过程中报错 在基类中声明为private 这样即使在成员函数和友元中使用相应拷贝控制成员，也会因为无法拷贝控制相应基类成员，从而将报错从链接期提前到编译期 在声明中标记为=delete 07：为多态基类声明virtual析构函数 声明多态性质的基类的析构函数为virtual的\n背景：当delete一个指向派生类的基类指针时，只会调用non-virtual的基类析构函数，派生类中成员无法释放 只有当类中至少包含一个除析构函数外的virtual函数时（多态性质），才将析构函数声明为virtual的 为了保持可移植性 如果该类不包含virtual函数，则通常该类不会作为基类 将基类析构函数声明为pure virtual函数，从而将基类构造为抽象基类（避免了考虑将其他哪个函数声明为pure virtual函数） 所有的STL容器都不包含virtual析构函数，因此不要将STL容器作为基类 因为STL容器设计不是用来作为基类，不带有多态语义要求，只有多态性质的基类才需要声明一个virtual析构函数 不是所有基类都带有多态性质 08：别让异常逃离析构函数 析构函数不要抛出异常，但是析构函数中可以使用try catch进行异常处理 C++11中，默认将析构函数声明为noexcept，防止在析构函数中抛出异常 try语句块中抛出异常时，会将作用域中对象依次调用析构函数，然后进入catch语句块中 如果此时调用的析构函数中继续报错，则core dumped 可以在析构函数中使用try catch捕获异常，或者重新设计接口，使得防止抛出异常的函数在析构函数中被调用 09：绝不在构造和析构过程中调用virtual函数 不要再构造/析构函数（及其调用的函数中）中调用virtual函数，因为这样虚函数不会呈现多态\n当派生类中的基类部分被构造时，其调用的虚函数只会调用基类中的版本，不会调用派生类中的版本，即不会呈现多态 从安全性角度看，因为此时派生类部分还未构造，使用派生类的虚函数版本可能产生未定义的行为，所以C++规定使用基类的版本 从原理角度看，在构造基类部分时，对象的类型实际上是基类类型 当派生类中的基类部分被析构时，同样不会呈现多态 从安全性角度看，此时派生类部分已经析构，调用派生类的虚函数版本产生未定义的行为 从原理角度看，此时对象为基类类型 构造函数/析构函数内调用的函数，也要保证其中不调用虚函数 10：令operator=返回一个reference to *this 令赋值运算符返回一个*this的引用\n11：在operator=中处理自我赋值 进行重新排列赋值或者copy and swap\n背景：有时可能很隐蔽的进行了自赋值的操作，特别是类管理资源时，很可能被意外delete掉 进行重新排列赋值：先保存当前资源副本，然后new，最后delete原来的资源；可以保证异常安全性，而且identity test没有必要 1 2 3 4 5 6 MyClass\u0026amp; operator= (const MyClass\u0026amp; rhs){ Resource* tmp = MyResource; MyResource = new Resource(); // 如果new失败，则当前资源不会被释放 delete tmp; // new成功 return *this; } copy and swap 12：复制对象时勿忘记其每一个成分 派生类复制时，不要忘记将基类部分也复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Base{ public: Base(int id): base_id(id) {} Base(const Base\u0026amp; b): base_id(b.base_id) {} Base\u0026amp; operator= (const Base\u0026amp; b) { base_id = b.base_id; return *this;} private: int base_id; }; class Derived: public Base{ public: Derived(int id, string name): Base(id), myname(name) {} Derived(const Derived\u0026amp; d): Base(d), myname(d.myname) {} // 将派生类直接赋值给基类，派生类被切掉 Derived\u0026amp; operator= (const Derived\u0026amp; d){ Base::operator=(d); // 调用基类operator= myname = d.myname; return *this; } private: string myname; }; ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch02-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/","summary":"05：了解C++默默编写并调用了哪些函数 如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成 有时编译器不会进行合成，","title":"[Effective Cpp Notes] Ch02 构造、析构、赋值运算"},{"content":"01 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分\nC++支持面向过程、面向对象、面向函数、泛型编程、元编程，因此可以将C++视为一个由相关语言组成的联邦而非单一语言（各个方面的编程范式不太相同）： C：有指针、数组，没有模板、重载和异常 Object-Oriented C++：类、封装、继承、多态、虚函数 Template C++：模板元编程 STL： 编程范式（或者编程技巧）的区别： 对于C而言，传值比传引用更加高效 对于Object-Oriented C++而言，常量引用传递往往更好（可以传递左值、右值） 对于Template C++而言，模板往往不知道处理的对象是什么类型 对于STL而言，迭代器和函数对象是基于C的指针，所以此时应该选择值传递 02：尽量以const,enum,inline替换#define 尽量使用编译器操作代替预处理器操作： 对于常量，尽量使用const对象或enum来替换#define 对于形似函数的宏，最好改用inline替换#define 尽量使用编译器操作代替预处理器操作 #define是在预处理阶段进行替换，宏的名字不会出现在符号表中。 对于常量，尽量使用const对象或enum来替换#define 两个典型场景： 定义常量指针 定义class专属常量，比如const static成员 类内static成员可以进行【声明时初始化】，虽然不是定义（即没有分配空间），但是只要不取地址，此时也可以使用该变量 如果类内static成员进行【声明时初始化】，而且需要取地址，则需要在类外对变量进行定义 1 2 3 4 class Widget{ const static int val = 0; }; const int Widget::val; // 由于const，无法进行赋值 对于形似函数的宏，最好改用inline替换#define 虽然使用宏本身少了一次调用过程，但是有时即使加上括号，结果也不正确 1 2 3 4 5 #define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a 累加了一次 CALL_WITH_MAX(++a, b + 10); // a 累加了两次 使用inline可以保证正确性，并且可以使用模板 参考 https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/02.PreferConstsEnumsInlinesToDefine.md 03：尽可能使用const 声明为const可以帮助编译器检测错误 const成员函数默认遵循bitwise constness，但是编写程序时应该使用logical constness，必要时将成员声明为mutable来保证可以修改 const和non-const成员函数有实质等价的实现，令non-const版本调用const版本可以避免代码重复 const和指针：顶层const与底层const const和STL：const迭代器是顶层const，const_iterator是底层const const和函数： 函数返回值和函数形参尽量声明为const的，有助于编译器定位相关报错 比如将比较运算符==误写为赋值运算符= 成员函数声明为const的 使得成员函数更容易被理解（这个成员函数不能修改成员），而且此时形参往往也是const引用 一个const成员函数，一个non-const成员函数，可以进行重载 const对象调用const版本成员函数，普通对象调用non-const版本成员函数 常量性转移 背景：const成员函数与non-const成员函数中间逻辑相同，可能存在大量的重复代码，一个方法是将重复的代码写成函数放在private中 更好的办法是，让non-const成员函数调用const成员函数（如果反过来，const成员函数调用non-const成员函数，不能保证对象不被修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class TextBlock{ public: const char\u0026amp; operator[] (std::size_t pos) const{ // do something return text[pos]; } char\u0026amp; operator[] (std::size_t pos) { return const_cast\u0026lt;char\u0026amp;\u0026gt;( static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this) // *this是TextBlock\u0026amp;, 强转加上const [pos] // const TextBlock\u0026amp;调用operator[]，否则TextBlock\u0026amp;调用operator[]一直重复调用自己 ); } private: std::string text; } mutable：使得成员变量即使在const成员函数中也可以被修改，主要是为了实现logical constness 背景：bitwise constness与logical constness bitwise constness：成员函数不应该修改任何non-static成员变量（const成员函数的默认方式） 编译器容易实现，只需要寻找成员变量的赋值操作 logical constness：允许成员函数修改成员变量，对于使用者而言，可以体现出constness即可 比如一个指针成员变量，按照bitwise constness，限定指针为顶层的，但是却无法保证不修改所指对象 参考 https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/03.UseConstWheneverPossible.md 04：确定对象被使用前已被初始化 内置类型对象一定要进行手动初始化 构造函数中最好使用初始化列表对成员变量进行初始化，而非在函数体中进行赋值 为了避免跨编译单元的初始化顺序问题，尽量以local static对象代替non-local static对象 内置类型变量的初始化 内置类型变量（即使是类中的内置类型成员变量）是否会初始化，取决于其在内存中的位置（堆空间？栈空间？） 自定义类对象的初始化 初始化与赋值的区别 赋值：比如在构造函数函数体中进行“赋值” 非内置类型的成员变量的初始化发生在进入构造函数之前，每个成员变量的default构造函数被自动调用，构造了两次（默认构造一次，复制构造一次） 但是内置类型的成员变量不会自动初始化，此时无区别 初始化：比如在构造函数初始化列表中 此时相当于只调用了一次成员变量的构造函数（赋值构造） 如果是const或者是引用，此时不能被赋值，只能进行初始化 变量初始化顺序 在初始化列表中，编译器按照父类-\u0026gt;子类的顺序进行成员变量初始化，但尽量还是与成员声明顺序保持一致 不同编译单元内定义的non-local static对象的初始化顺序 一些情况下，不同编译单元内的non-local static对象的初始化顺序有要求，但是C++没有明确定义（比如要求先FileSystem中tfs初始化，后Diectory中tdr初始化） 将每个 non-local static 对象移至自己的专属函数内（变成 local static 对象） ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch01-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc++/","summary":"01 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分 C++支持面向过程、面向对象、面向函数、泛型编程、元编程","title":"[Effective Cpp Notes] Ch01 让自己习惯C++"},{"content":"contact me at: zhangqingannn@gmail.com\n","permalink":"https://qinganzhang.github.io/about/","summary":"contact me at: zhangqingannn@gmail.com","title":"About"}]