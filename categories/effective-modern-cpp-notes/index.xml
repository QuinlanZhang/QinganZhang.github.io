<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>effective-modern-cpp-notes on Paul&#39;s Blog</title>
    <link>https://qinganzhang.github.io/categories/effective-modern-cpp-notes/</link>
    <description>Recent content in effective-modern-cpp-notes on Paul&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 01 Feb 2024 21:56:31 +0800</lastBuildDate><atom:link href="https://qinganzhang.github.io/categories/effective-modern-cpp-notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Effective Modern Cpp Notes] Ch08 微调</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/</link>
      <pubDate>Thu, 01 Feb 2024 21:56:31 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch07 并发API</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/</link>
      <pubDate>Thu, 01 Feb 2024 21:56:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>Effective Modern Cpp Reading Notes</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/</link>
      <pubDate>Thu, 01 Feb 2024 21:53:53 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch06 Lambda表达式</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 01 Feb 2024 21:48:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但</description>
      <content:encoded><![CDATA[<h1 id="31避免默认捕获模式">31：避免默认捕获模式</h1>
<ul>
<li>闭包：lambda所创建的运行期对象</li>
<li>默认捕获可能导致引用悬挂
<ul>
<li>默认传引用可能导致引用悬挂
<ul>
<li>显式传引用也可能导致引用悬挂，但是可以更容易发现此处可能有引用悬挂</li>
</ul>
</li>
<li>默认传值捕获也可能导致引用悬挂</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">filters</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    void addFilter() const{
</span></span></span><span class="line"><span class="cl"><span class="c1">//        filters.emplace_back(
</span></span></span><span class="line"><span class="cl"><span class="c1">//            [=](int value) {return value % divisor == 0;} 
</span></span></span><span class="line"><span class="cl"><span class="c1">//        ); // 看似是传值捕获，不会有引用悬挂；但是lambda只能捕获作用域中的非静态局部变量，此处的divisor其实是this-&gt;divisor，容易产生引用悬挂
</span></span></span><span class="line"><span class="cl"><span class="c1">//    }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 解决方法：使用一个局部变量复制成员变量，然后使用显式的值捕获
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">[</span><span class="n">divisorCopy</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>lambda只能捕获作用域中的非静态局部变量，无法捕获静态或全局变量
<ul>
<li>捕获表示将值拷贝到闭包类中，而lambda中使用静态或全局变量，相当于是对外部的引用，因此此时lambda不是独立的</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125037605">https://blog.csdn.net/Dong_HFUT/article/details/125037605</a></li>
</ul>
</li>
</ul>
<h1 id="32使用初始化捕获将对象移入闭包">32：使用初始化捕获将对象移入闭包</h1>
<ul>
<li>C++14使用<strong>初始化捕获模式</strong>（也称广义lambda捕获）来实现移动捕获</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()]</span> <span class="c1">// 左边是lambda闭包内成员名称，右边是初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span><span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11使用<code>std::bind</code>间接实现移动捕获</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">pw</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();},</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125111586">https://blog.csdn.net/Dong_HFUT/article/details/125111586</a></li>
</ul>
</li>
</ul>
<h1 id="33泛型lambda的完美转发版本">33：泛型lambda的完美转发版本</h1>
<blockquote>
<p>对<code>auto&amp;&amp;</code>类型的形参使用<code>decltype</code>，以<code>std::forward</code>之</p>
</blockquote>
<ul>
<li>泛型lambda（C++14）：可以使用auto声明形参（即闭包类中的<code>operator()</code>可以使用模板实现）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包类中的operator()的大致实现：auto形参实际上是模板类型推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SomeCompilerGeneratedClassName</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>泛型lambda的完美转发版本：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">);}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包类中的operator()的大致实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SomeCompilerGeneratedClassName</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...</span> <span class="p">);}</span> <span class="c1">// 变长参数版本
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125116613">https://blog.csdn.net/Dong_HFUT/article/details/125116613</a></li>
</ul>
</li>
</ul>
<h1 id="34优先选用lambda表达式而非stdbind">34：优先选用lambda表达式，而非<code>std::bind</code></h1>
<blockquote>
<p>对于C++11，除了个别边缘case，lambda比<code>std::bind</code>更有优势；C++14，lambda完全可以替代<code>std::bind</code></p>
</blockquote>
<ul>
<li>lambda可读性更强，更容易理解
<ul>
<li>使用<code>std::bind</code>需要保持参数位置，同时需要了解其实现机制
<ul>
<li><code>std::bind</code>需要保持参数位置，因此使用时需要查看原来函数的声明，才能知道占位符对应的参数类型和参数含义；但是lambda形参列表很明确</li>
<li><code>std::bind</code>默认将参数拷贝到绑定对象内部（可以使用<code>std::ref</code>指定传引用），但是lambda可以明确指出值捕获还是引用捕获</li>
<li><code>std::bind</code>绑定对象的函数调用使用了完美转发机制，但是lambda可以从形参列表中清晰看出传值还是传引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">Logger</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logger</span><span class="p">]</span> <span class="p">(</span><span class="n">CompressLevel</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">compress</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 捕获对象：w值捕获，logger引用捕获；形参：level传值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">logger</span><span class="p">));</span> <span class="c1">// 需要对应参数顺序
</span></span></span><span class="line"><span class="cl"><span class="c1">// 绑定对象：w值绑定（复制），logger引用绑定；形参：level使用完美转发机制
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>std::bind</code>参数绑定和对象调用不是一个时间，因此可能出现逻辑错误（见参考）</li>
</ul>
</li>
<li>lambda灵活性更强
<ul>
<li>如果<code>std::bind</code>绑定的函数存在重载版本，则编译器无法确定使用哪个版本的重载函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">funcType</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">bnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">funcType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>lambda可以内联
<ul>
<li>因为<code>std::bind</code>中绑定的是函数指针，需要在运行时才能确定；但是lambda中包含函数体，可以进行内联</li>
</ul>
</li>
<li>使用<code>std::bind</code>的两个场景：在C++11中
<ul>
<li>使用<code>std::bind</code>间接实现移动捕获（[[ch06-lambda表达式#32：使用初始化捕获将对象移入闭包|C++14支持移动捕获]]）</li>
<li>使用<code>std::bind</code>绑定参数的完美转发机制，间接多态函数对象（[[ch06-lambda表达式#33：泛型lambda的完美转发版本|C++14支持泛型lambda]]）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">callableObject</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span> <span class="n">callableObject</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CallableObject</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">CallableObject</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 将占位符参数完美转发到可调用对象的调用运算符中
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125130410">https://blog.csdn.net/Dong_HFUT/article/details/125130410</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch05 右值引用、移动语句和完美转发</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Thu, 01 Feb 2024 21:48:16 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为</description>
      <content:encoded><![CDATA[<h1 id="23理解stdmove和stdforward">23：理解<code>std::move</code>和<code>std::forward</code></h1>
<ul>
<li><code>std::move</code>：返回变量的右值引用
<ul>
<li>对const对象的移动操作会被转换为拷贝操作
<ul>
<li>因为const对象经过<code>std::move</code>会返回一个const右值引用，而一般函数重载的移动版本形参都是非const的右值引用，无法匹配</li>
</ul>
</li>
<li><code>std::move</code>不移动对象，而且也不保证对象一定被移动，仅仅返回对象的右值引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>             <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>std::forward</code>：实现完美转发（保持对象的左值性或右值性）
<ul>
<li>通常情况下，形参总是左值，即使其类型是右值引用</li>
</ul>
</li>
<li><code>std::move</code>和<code>std::forward</code>只是进行类型转换，在运行时不做任何事</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123765869">https://blog.csdn.net/Dong_HFUT/article/details/123765869</a></li>
</ul>
</li>
</ul>
<h1 id="24区分万能引用和右值引用">24：区分万能引用和右值引用</h1>
<blockquote>
<p>万能引用和右值引用只是形式上类似，但这是两个概念</p>
</blockquote>
<ul>
<li>万能引用：形式为<code>T&amp;&amp;</code>或<code>auto&amp;&amp;</code>，并且存在类型推导
<ul>
<li>函数模板参数：<code>template &lt;typename T&gt; void func(T&amp;&amp; param);</code></li>
<li>auto类型推导：<code>auto&amp;&amp; val = myVal;</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">myFunc</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* do something */</span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>右值引用
<ul>
<li>带const（不是纯粹的<code>T&amp;&amp;</code>形式）：<code>template &lt;typename T&gt; void func(const T&amp;&amp; param);</code></li>
<li>形式是<code>T&amp;&amp;</code>，但是不存在类型推导：比如vector的<code>push_back</code>，但是<code>emplace_back</code>中参数是万能引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 调用push_back时，类型T已知
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span> <span class="c1">// 参数包args的类型Args独立于T，存在类型推导，这里是万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123773321">https://blog.csdn.net/Dong_HFUT/article/details/123773321</a></li>
</ul>
</li>
</ul>
<h1 id="25针对右值引用实施stdmove针对万能引用实施stdforward">25：针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span> <span class="c1">// 以例子来说明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">sp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">sp</span><span class="p">))</span> <span class="p">{}</span> <span class="c1">// 形参为右值引用，将形参（左值）进行移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">){</span> <span class="c1">// 形参为万能引用，保持形参的左值性或右值性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;set new name:&#34;</span><span class="o">&lt;&lt;</span><span class="n">newName</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="c1">// 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">doNothing</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>重载<code>setName</code>不是一个好的设计
<ul>
<li>可能效率低：如果传入字面量，即使匹配到右值版本的函数，形参仍然会作为临时对象</li>
<li>如果有多个参数，需要重载$2^N$种，如果使用参数包，则无法实现</li>
</ul>
</li>
<li>在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候</li>
<li>如果函数中将形参进行处理，然后返回
<ul>
<li>传值返回：如果形参是右值引用（比如<code>Widget operator+</code>成员函数），使用move返回；如果形参是万能引用（比如<code>doNothing</code>成员函数），使用forward返回</li>
<li>如果返回值是函数中的局部变量，则编译器有特定的优化：<a href="https://blog.csdn.net/Dong_HFUT/article/details/123911978">RVO</a></li>
</ul>
</li>
<li>返回值优化RVO（Return Value Optimization）：减少函数返回时产生临时对象，进而消除部分拷贝或移动操作
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 原来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 有一次默认构造，一次拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// 再加上一次拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用RVO优化，上面过程相当于：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> <span class="n">w</span><span class="p">.</span><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// Widget w在外面分配空间，直接传入func中进行构造，因此只需要一次（默认）构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// NRVO(Named Return Value Optimization)原理类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// 返回对象已经具名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>使用前提：局部对象的类型和返回值类型相同，而且局部对象就是返回值</li>
<li>限制场景：
<ul>
<li>返回<code>std::move()</code>：默认构造+移动构造</li>
<li>进行赋值而非初始化<code>Widget w; w = func();</code>：默认构造+func中的默认构造和拷贝构造</li>
<li>不同的分支条件下，返回不同的局部对象</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123946594">https://blog.csdn.net/Dong_HFUT/article/details/123946594</a></li>
</ul>
</li>
</ul>
<h1 id="26避免依万能引用类型进行重载">26：避免依万能引用类型进行重载</h1>
<ul>
<li>原因：函数匹配规则
<ul>
<li>如果模板实例化出的函数和普通重载函数都精确匹配，则优先选择普通重载函数，其次选择模板函数实例化出来的精确版本</li>
</ul>
</li>
<li>例子</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>        
</span></span><span class="line"><span class="cl">        <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 对Person(int)的重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Person</span> <span class="nf">p1</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// 会调用模板实例化的版本，而非进行类型转换调用普通版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">Person</span> <span class="nf">p2</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个情况极其容易混淆，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Person</span> <span class="nf">q2</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">// 会调用生成的拷贝构造函数（因为其实参为const Person&amp;）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Person</span> <span class="nf">q1</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// 会调用模板实例化的版本，而非调用生成的拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 尤其当Person作为基类，派生类在构造函数中初始化基类部分时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SpecialPerson</span><span class="o">:</span> <span class="k">public</span> <span class="n">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpecialPerson</span><span class="p">(</span><span class="k">const</span> <span class="n">SpecialPerson</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpecialPerson</span><span class="p">(</span><span class="n">SpecialPerson</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这两个构造函数均使用基类Person构造函数的完美转发版本，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对万能引用参数的函数进行重载，不是一个好的设计
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="27熟悉依万能引用类型进行重载的替代方案">27：熟悉依万能引用类型进行重载的替代方案</h1>
<ul>
<li>
<p>放弃重载，使用不同的函数名</p>
<ul>
<li>但是对于构造函数就无能为力</li>
</ul>
</li>
<li>
<p>普通函数形参为<code>const type&amp;</code>类型</p>
<ul>
<li>因此传入const实参，会优先使用原来的普通版本，而非重载的万能引用版本</li>
</ul>
</li>
<li>
<p>将形参从引用类型换成值类型：当知道肯定要复制形参时，考虑按值传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用Tag分发：使用Tag对参数进行区分，进而分发到不同的函数实现</p>
<ul>
<li>背景：如果想使用完美转发，就必须要使用万能引用</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 两个函数实现的版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用Tag对参数进行区分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logAndAddImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span> <span class="c1">// 或者C++14：std::is_integral&lt;typename std::remove_reference_t&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果传入true or false，到运行时才能决定</li>
<li>在编译阶段进行模板匹配，<code>std::is_integral</code>在编译阶段就可以判断类型是否为整型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>约束接受万能引用的模板：<code>std::enable_if</code>判断</p>
<ul>
<li>背景：构造函数无法使用Tag分发</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of_v</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl">                <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>                    
</span></span><span class="line"><span class="cl">            <span class="o">&gt;</span>            
</span></span><span class="line"><span class="cl">    <span class="o">&gt;</span> <span class="c1">// 当类型T不为Person或者其派生类，抑或T不为int型时，才会选择这个的重载版本，使用万能引用进行重载并实现完美转发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">::</span><span class="n">value</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="s">&#34;Parameter name can&#39;t be used to construct a std::string&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span> <span class="c1">// 验证类型为std::string的对象能否被类型为T的对象构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>std::enable_if&lt;condition&gt;::type</code>：只有满足条件的模板才会使用（C++14<code>std::enable_if_t</code>）</li>
<li><code>std::is_same&lt;T1, T2&gt;::value</code>（C++17<code>std::is_same_v</code>）</li>
<li><code>std::is_base_of&lt;T1, T2&gt;::value</code>：如果T2继承于T1，则为true；且<code>std::is_base_of&lt;T, T&gt;::value==true</code>（C++17<code>std::is_base_of_v</code>）</li>
<li><code>std::decay&lt;T&gt;::type</code>的类型与T的类型相同，忽略了引用、const、volatile（C++14<code>std::decay_t</code>）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>权衡</p>
<ul>
<li>前三种方案都需要对需要调用的函数形参逐一指定其类型，后两种方案使用万能引用实现了完美转发</li>
<li>虽然完美转发效率更高（避免创建临时对象），但是某些对象无法实现完美转发，并且使用完美转发并编译报错时，报错信息的可读性很差
<ul>
<li><code>std::is_constructible</code>可以在编译期测试一个类型的对象能否被另一个不同类型的对象（或者多个不同类型的多个对象）构造，因此可以用来验证转发函数的万能引用参数是否合法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>参考</p>
<ul>
<li>SFINAE技术</li>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124227488">https://blog.csdn.net/Dong_HFUT/article/details/124227488</a></li>
</ul>
</li>
</ul>
<h1 id="28理解引用折叠">28：理解引用折叠</h1>
<ul>
<li>几种引用折叠的应用场景：
<ul>
<li>万能引用的实例化：在模板类型推导时，可能出现“引用的引用”的情况，此时需要用到引用折叠</li>
<li><code>std::forward</code>完美转发：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>auto类型推导，decltype类型推导</li>
<li>typedef类型别名</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124517043">https://blog.csdn.net/Dong_HFUT/article/details/124517043</a></li>
</ul>
</li>
</ul>
<h1 id="29假定移动操作不存在成本高未使用">29：假定移动操作不存在、成本高、未使用</h1>
<ul>
<li>几种移动语义不可用、不高效的情况：
<ul>
<li>没有移动操作：编译器只有在没有用户自定义拷贝操作和析构函数时，才自动生成移动操作</li>
<li>移动未能更快：
<ul>
<li><code>std:array</code>
<ul>
<li>一般STL中容器的对象都分配在堆上，对象中有指向堆上内存的指针，因此移动操作只需要进行指针的更新、源对象的指针置空即可</li>
<li>但是<code>std::array</code>中内容分配在栈上（栈上的数组），移动操作等于复制操作</li>
</ul>
</li>
<li><code>std::string</code>
<ul>
<li><code>std::string</code>针对小对象有一个优化SSO（Small String Optimization），小对象直接存储在栈上而非堆上，省去动态内存分配</li>
</ul>
</li>
</ul>
</li>
<li>移动不可用：移动操作没有标记为<code>noexcept</code>
<ul>
<li>如果移动操作没有标记为<code>noexcept</code>，即使是适合使用移动操作的场景，编译器也会使用复制操作替代</li>
</ul>
</li>
<li>源对象是左值：只有右值可以作为移动操作的源（左值可以用，但是很容易造成空悬问题）</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124577258">https://blog.csdn.net/Dong_HFUT/article/details/124577258</a></li>
</ul>
</li>
</ul>
<h1 id="30熟悉完美转发的失败情形">30：熟悉完美转发的失败情形</h1>
<ul>
<li>完美转发的含义：不仅转发对象，而且转发其特征（左值、右值、const、volatile）</li>
<li>完美转发的失败情形
<ul>
<li>列表初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> <span class="c1">// 编译报错：无法推断出T的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">il</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">il</span><span class="p">);</span> <span class="c1">// T=initializer_list&lt;int&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>0或NULL作为空指针
<ul>
<li>0或NULL会被推导为int型而非空指针类型，因此完美转发后得到的类型是int，但是形参是指针类型</li>
</ul>
</li>
<li>仅仅声明整型的静态常量数据成员
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">cosnt</span> <span class="kt">int</span> <span class="n">cnst</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// 声明而非定义，不会分配实际的存储空间，而是常量传播（直接将用到cnst的地方替换为12）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">Widget</span><span class="o">::</span><span class="n">cnst</span><span class="p">);</span> <span class="c1">// 编译报错：找不到cnst的定义
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>只声明不会分配空间，因此无法取地址，也无法使用引用，不能使用完美转发</li>
<li>解决方法：在类外或是对应.cpp文件中添加定义：<code>const int cnst = 12;</code></li>
</ul>
</li>
<li>函数重载和函数模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">func</span><span class="p">);</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">func</span><span class="p">);</span> <span class="c1">// 模板类型推导失败：无法确定是哪个重载版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 解决方法：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">FuncType</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">FuncType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 但是万能引用和完美转发一般是针对任意类型的，这里限定了类型，语义与实现矛盾
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>位域：位域只是int类型的一部分，没有一个确切地址，也就无法引用</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124787082">https://blog.csdn.net/Dong_HFUT/article/details/124787082</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch04 智能指针</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:58 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋</description>
      <content:encoded><![CDATA[<h1 id="18使用stdunique_ptr管理具备专属所有权的资源">18：使用<code>std::unique_ptr</code>管理具备专属所有权的资源</h1>
<ul>
<li><code>std::unique_ptr</code>表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋值是delete的），只能进行移动操作从而转移资源控制权
<ul>
<li>例外：可以从函数返回一个<code>std::unique_ptr</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">delInt</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;My deleter&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delInt</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pInt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">delInt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>删除器是<code>std::unique_ptr</code>类型的一部分
<ul>
<li>在不定义删除器的情况下，<code>std::unique_ptr</code>内存占用和原始指针相同</li>
<li>如果自定义删除器，则<code>std::unique_ptr</code>内存占用会变大</li>
</ul>
</li>
<li><code>std::unique_ptr</code>可以指向数组，默认删除器为<code>delete[]</code>：<code>std::unique_ptr&lt;int[]&gt; p(new int[5]{1,2,3,4,5});</code>
<ul>
<li>但是数组形式用到的场合很少，尽量使用STL</li>
</ul>
</li>
<li><code>std::unique_ptr</code>可以直接隐式转换为<code>std::shared_ptr</code></li>
<li>典型应用：针对继承体系，作为工厂函数的返回值类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">makeAnimal</span><span class="p">(</span><span class="n">AnimalType</span> <span class="n">type</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">AnimalInfo</span><span class="p">){</span> <span class="c1">// C++14中函数返回值可以写为auto，因此unique_ptr的删除器可以放在函数内部，否则显式写出返回类型时需要知道删除器类型，因此删除器只能写在函数外部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">delAnimal</span> <span class="o">=</span> <span class="p">[](</span><span class="n">AnimalType</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">makeMyLog</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delAnimal</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">delAnimal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Dog</span><span class="p">)</span> <span class="n">up</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Dog</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AnimalInfo</span><span class="p">)...));</span> <span class="c1">// 参数是万能引用，这里进行完美转发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Cat</span><span class="p">)</span> <span class="n">up</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AnimalInfo</span><span class="p">)...));</span> <span class="c1">// 使用reset使得指针独占资源的所有权，不能直接将原始指针赋值给智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">up</span><span class="p">;</span> <span class="c1">// 返回unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123465058">https://blog.csdn.net/Dong_HFUT/article/details/123465058</a></li>
</ul>
</li>
</ul>
<h1 id="19使用stdshared_ptr管理具备共享所有权的资源">19：使用<code>std::shared_ptr</code>管理具备共享所有权的资源</h1>
<ul>
<li><code>std::shared_ptr</code>可以拷贝，通过引用计数来管理资源的生命周期</li>
<li><code>std::shared_ptr</code>内存模型
<ul>
<li>一个<code>std::shared_ptr</code>大小通常为普通指针的两倍：一个指针指向资源，另一个指针指向控制块</li>
<li>控制块中通过原子操作维护引用计数，保存deleter（因此deleter不属于<code>std::shared_ptr</code>类型的一部分），保存弱计数等</li>
</ul>
</li>
<li><code>std::shared_ptr</code>的使用：
<ul>
<li>使用<code>std::make_shared</code>、<code>std::unique_ptr</code>、原始指针创建<code>std::shared_ptr</code>，会为资源创建一个控制块
<ul>
<li>如果资源有多个控制块，就会被多次析构，因此尽量避免使用原始指针构造<code>std::shared_ptr</code></li>
</ul>
</li>
<li>使用<code>std::shared_ptr</code>或<code>std::weak_ptr</code>创建一个<code>std::shared_ptr</code>，不会创建一个新的控制块</li>
<li><code>this</code>的陷阱：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(this));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">myCat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myCat</span><span class="o">-&gt;</span><span class="n">eat</span><span class="p">();</span> <span class="c1">// 针对同一个对象创建了两个控制块
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>解决方法一：使类继承自<code>std::enable_shared_from_this</code>，类内部使用<code>shared_from_this</code>方法，搜索当前对象的控制块，如果有就不用创建控制块了，如果没有则抛出异常，因此适合于当前对象已经创建过控制块的情况
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(shared_from_this()));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">myCat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myCat</span><span class="o">-&gt;</span><span class="n">eat</span><span class="p">();</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>解决方法二：见127页，代码是自己实现的，有误
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Animal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">foward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">            <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(shared_from_this()));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Animal</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123599599">https://blog.csdn.net/Dong_HFUT/article/details/123599599</a></li>
</ul>
</li>
</ul>
<h1 id="20对于类似stdshared_ptr但是可能空悬的指针使用stdweak_ptr">20：对于类似<code>std::shared_ptr</code>但是可能空悬的指针使用<code>std::weak_ptr</code></h1>
<ul>
<li><code>std::weak_ptr</code>通常视为<code>std::shared_ptr</code>的辅助工具，通过<code>std::shared_ptr</code>构造<code>std::weak_ptr</code>
<ul>
<li><code>std::weak_ptr</code>不会影响对象的引用计数</li>
<li>但是<code>std::weak_ptr</code>没有解引用操作，必须调用<code>lock</code>转换为<code>std::shared_ptr</code>来访问对象
<ul>
<li>例子：<code>if(shared_ptr&lt;int&gt; p = wp.lock()&gt; cout&lt;&lt;*p&lt;&lt;endl;</code></li>
</ul>
</li>
</ul>
</li>
<li>典型应用：
<ul>
<li>避免<code>shared_ptr</code>循环引用：将其中一个<code>shared_ptr</code>改为<code>weak_ptr</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span><span class="p">;</span> <span class="c1">// std::weak_ptr&lt;B&gt; pb;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pa</span><span class="o">-&gt;</span><span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span> <span class="c1">// pb和pa-&gt;pb同时指向同一个对象B，引用计数为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>带缓存的工厂方法
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">fastLoadWidget</span><span class="p">(</span><span class="n">WidgetID</span> <span class="n">id</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">WidgetID</span><span class="p">,</span> <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;&gt;</span>  <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widgetPtr</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">widgetPtr</span><span class="p">){</span> <span class="c1">// 缓存中没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">widgetPtr</span> <span class="o">=</span> <span class="n">loadWidget</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// 调用原始工厂方法创建，并加入到缓存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">widgetPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">widgetPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>观察者设计模式：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123612236">https://blog.csdn.net/Dong_HFUT/article/details/123612236</a></li>
</ul>
</li>
</ul>
<h1 id="21优先选用stdmake_unqiue和stdmake_shared而非直接使用new">21：优先选用<code>std::make_unqiue</code>和<code>std::make_shared</code>，而非直接使用new</h1>
<ul>
<li>make函数可以传入任意集合的参数，然后完美转发给构造函数，并动态创建一个对象，返回智能指针
<ul>
<li>支持auto</li>
<li>避免异常：将[[ch03-资源管理#17：以独立语句将new的对象置入智能指针| effective C++ item17：以独立语句将new的对象置入智能指针]]改进为使用make函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 可能由于异常导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 不会由于异常导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果需要自定义删除器，并且又可以避免异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">myDeleter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 直接传递一个右值，避免了修改引用计数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>效率更高：make函数只需要申请一次内存（同时存储对象和控制块），但是使用<code>shared_ptr&lt;Widget&gt;(new Widget)</code>需要申请两次内存（一次对象，一次控制块）</li>
<li>make函数的缺点：
<ul>
<li>无法自定义deleter</li>
<li>语义歧义：比如使用<code>()</code>和<code>{}</code>初始化vector代表不同的方式，make函数可以完美转发<code>()</code>，不支持完美转发<code>{}</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// {3,3};
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">initList</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">initList</span><span class="p">);</span> <span class="c1">// 不支持：make_shared&lt;vector&lt;int&gt;&gt;({1,2,3,4,5});
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。</li>
<li>若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数，会导致对象的析构和内存的释放之间产生延迟
<ul>
<li>如果只申请一块内存（make函数），如果后来<code>shared_ptr</code>的引用计数为0，但是<code>weak_ptr</code>的引用计数不为0时，对象销毁会被延长，只有当<code>weak_ptr</code>的引用计数为0时，控制块才被释放</li>
<li>如果使用new的话，可以立即销毁对象</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123622543">https://blog.csdn.net/Dong_HFUT/article/details/123622543</a></li>
</ul>
</li>
</ul>
<h1 id="22使用pimpl习惯用法时将特殊成员函数的定义放到实现文件中">22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h1>
<ul>
<li>PImpl技术（Pointer to Implementation，编译防火墙）：将类的实现放在另一个单独的类中，并通过不透明的指针进行访问。因此可以有效减少编译依赖。
<ul>
<li>原理：一个只声明但是不定义的类型是不完整类型，声明指向它的指针是可以通过编译的</li>
</ul>
</li>
<li>常见错误：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>                 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">  
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">()){}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;main.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// 报错：/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete type ‘Widget::Impl’
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>报错原因：在析构<code>Widget w</code>时，此时看到的<code>Impl</code>是不完整类型
<ul>
<li>在编译<code>widget.cpp</code>时没有问题：<code>g++ -c widget.cpp -o widget.o</code></li>
<li>在编译<code>main.cpp</code>时出问题：<code>g++ -c main.cpp -o main.o</code>
<ul>
<li>没有定义<code>Widget</code>的析构函数，因此使用自动生成的析构函数（默认是<code>inline</code>的）</li>
<li>本来如果声明了<code>Widget</code>的析构函数，编译时无法进行处理，后面链接时链接到定义，运行时才能析构<code>pImpl</code>（因为经过链接，此时也知道<code>Impl</code>是完整类型）</li>
<li>但是正因为自动生成的析构函数是<code>inline</code>的，编译时就可以展开，此时析构<code>pImpl</code>当然看到的<code>Impl</code>是不完整类型（还没有链接到<code>widget.o</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用说明
<ul>
<li>考虑到如上报错和[[ch03-转向现代C++#17：理解特殊成员函数的生成机制|item17：理解特殊成员函数的生成机制]]，因此最好将拷贝控制成员和析构函数自定义，且声明与实现分离（防止进行内联）</li>
<li>为了实现PImpl技术，使用<code>unique_ptr</code>是最合适的，因为<code>pImpl</code>指针独享<code>Impl</code>的所有权，如果使用<code>shared_ptr</code>则上述报错不会出现（因为删除器不属于类型的一部分，属于控制块，不会包含删除器的代码）</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123704824">https://blog.csdn.net/Dong_HFUT/article/details/123704824</a></li>
<li><a href="https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp">https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp</a></li>
</ul>
</li>
<li>实例
<ul>
<li><code>widget.h</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// std::string _name;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>widget.cpp</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_name</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pImpl</span> <span class="o">=</span> <span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Widget</span><span class="o">::</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pImpl</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>main.cpp</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;iostream&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">(</span><span class="s">&#34;zhang&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">w</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43;</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:37 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/</guid>
      <description>07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限</description>
      <content:encoded><![CDATA[<h1 id="07在创建对象时注意区分和">07：在创建对象时注意区分<code>()</code>和<code>{}</code></h1>
<ul>
<li>初始化方式
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">x1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x3</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 统一初始化（列表初始化）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// 和第三种方式相同
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>()</code>和<code>=</code>初始化的限制
<ul>
<li><code>()</code>不能用于non-static成员的初始化</li>
<li>不能拷贝的对象不能使用<code>()</code>初始化</li>
</ul>
</li>
<li><code>{}</code>初始化的优点
<ul>
<li>禁止基本类型之间的隐式窄化类型转换：比如不能使用double初始化int型变量</li>
<li>避免了C++复杂的语法分析：<a href="https://blog.csdn.net/Dong_HFUT/article/details/126435993">C++&rsquo;s most vexing parse</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 传入一个实参，构造出一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w2</span><span class="p">();</span> <span class="c1">// 本来想调用无形参的构造函数构造一个对象，但是实际上声明了一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{};</span> <span class="c1">// 调用无形参的构造函数，构造出一个对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>{}</code>的缺陷
<ul>
<li>auto类型推导中使用<code>{}</code>进行初始化，则auto被推断为<code>initializer_list&lt;T&gt;</code></li>
<li>会优先使用形参为<code>initializer_list&lt;T&gt;</code>的构造函数，即使其他的构造函数更加匹配
<ul>
<li>只有当<code>{}</code>中参数无法转换为<code>initializer_list</code>中类型时，编译器才匹配普通函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;0&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;move copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;convert to int&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(int i, bool d)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span> <span class="c1">// 编译报错，本来调用Widget(initializer_list&lt;int&gt; il)，但是使用{}初始化禁止窄化类型转换（存在从double到int的转换）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{</span><span class="n">w1</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)（中间先将w1转为int），即使Widget(const Widget&amp; w)更加匹配（如果w1无法转换为int，则调用该构造函数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w1</span><span class="p">)};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(Widget&amp;&amp; w)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 特殊情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{};</span> <span class="c1">// 调用Widget()，而非调用Widget(initializer_list&lt;int&gt; il)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w5</span><span class="p">{{}};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w6</span><span class="p">({});</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>使用模板创建对象时，仔细考虑使用<code>()</code>还是<code>{}</code>进行初始化
<ul>
<li>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">){</span> <span class="c1">// 使用可变参数模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="nf">localVector1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">localVector2</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 推断出T=vector&lt;int&gt;, Ts=int
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector1: 4,4,4
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector2: 3,4
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122811753">https://blog.csdn.net/Dong_HFUT/article/details/122811753</a></li>
</ul>
</li>
</ul>
<h1 id="08优先选用nullptr而非0或null">08：优先选用nullptr，而非0或NULL</h1>
<ul>
<li>字面量0是一个int，NULL的实现为0L，可以转换为int，bool，<code>void*</code></li>
<li><code>nullptr</code>可以理解为任意类型的空指针
<ul>
<li>使得重载函数的调用明确</li>
<li>提高代码的清晰度</li>
<li>使用类型推导时，<code>nullptr</code>可以隐式转换为任意类型指针</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122891898">https://blog.csdn.net/Dong_HFUT/article/details/122891898</a></li>
</ul>
</li>
</ul>
<h1 id="09优先选用别名声明而非typedef">09：优先选用别名声明，而非typedef</h1>
<ul>
<li><code>using</code>别名的优点：
<ul>
<li>清晰，比<code>typedef</code>更容易理解</li>
<li>可以直接对模板起别名
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 如果非要使用typedef，需要包装一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyAllocList</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list1</span><span class="p">;</span> <span class="c1">// list1=std::list&lt;T, MyAlloc&lt;T&gt;&gt;,此时MyAllocList一定是一个别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list2</span><span class="p">;</span> <span class="c1">// list2=MyAllocList&lt;T&gt;中的std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 需要使用typename显式说明MyAllocList&lt;T&gt;::type是一个类型，而非数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>应用：标准库的<code>&lt;type_traits&gt;</code>中提供了一整套用于类型转换的类模板
<ul>
<li>虽然C++11中仍然是使用<code>typedef</code>实现的，但是C++14中是使用<code>using</code>声明实现的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="c1">// C++11中, 是一个内部包裹typedef的类模板，将T中的const属性移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>     <span class="c1">// C++14中, 是一个类模板中typedef别名的别名，将T中的const属性移除
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122847510">https://blog.csdn.net/Dong_HFUT/article/details/122847510</a></li>
</ul>
</li>
</ul>
<h1 id="10优先选用限定作用域的枚举类型而非不限作用域的枚举类型">10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h1>
<ul>
<li>无作用域限制的枚举（unscoped enums，C++98）
<ul>
<li>有时使用可能简便一点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">UserInfo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="c1">//name, email,age
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">UserInfoFields</span> <span class="p">{</span><span class="n">uiName</span><span class="p">,</span> <span class="n">uiEmail</span><span class="p">,</span> <span class="n">uiAge</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 位置1为email
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">uiEmail</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 冗余
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// C++14下的辅助类:既想使用有作用限制的枚举，又不想过于啰嗦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">toUType</span><span class="p">(</span><span class="n">E</span> <span class="n">enumerator</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">enumerator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">toUType</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>有作用域限制的枚举（scoped enums，C++11）
<ul>
<li>减少名称污染
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">black</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，因此枚举类型暴露在{}之外
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">red</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 有作用域限制的枚举，枚举类型限制在{}之内，因此减少名称污染
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>有强类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，可以发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d2</span> <span class="o">=</span>  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scopedColor</span><span class="o">::</span><span class="n">red</span><span class="p">);</span> <span class="c1">// 有作用域限制的枚举，不会发生隐式类型转换，类型转换需要显式说明
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以前向声明：只有在指定底层类型后，才能进行前向声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">;</span> <span class="c1">// 没有提供默认底层类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="k">class</span><span class="err">; //默认底层类型为</span><span class="nc">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122914289">https://blog.csdn.net/Dong_HFUT/article/details/122914289</a></li>
</ul>
</li>
</ul>
<h1 id="11优先选用删除函数而非private未定义函数">11：优先选用删除函数，而非private未定义函数</h1>
<ul>
<li>背景：编译期会自动生成某些函数，但是有时不需要这些函数；</li>
<li>C++98的做法：声明为private的，且只声明不定义（effective C++中item6）
<ul>
<li>在private中声明但是不定义，使之在链接阶段因为没有定义而报错</li>
<li>在基类中声明为private的，会因为无法拷贝控制派生类中的基类部分，将报错从链接期提前到编译期</li>
</ul>
</li>
<li>C++11的做法：在声明中标记为<code>=delete</code>
<ul>
<li>将删除的函数声明为public的，原因是编译器先检查访问权限，再检查delete状态。如果将删除的函数声明为private的，调用删除的函数时，可能报错原因提示是private的；但是更期望的更明确的含义是这些函数是删除的</li>
<li><code>=delete</code>可以在任意函数中进行标记，不仅仅局限于成员函数</li>
</ul>
</li>
<li>应用：
<ul>
<li>比如可以阻止某些形参的隐式类型转换
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> <span class="c1">// 因此禁止double和float两种参数的调用（C++总是倾向于将 float 转换为 double）
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>阻止某些模板类型的实例化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 成员模板函数在类外阻止某些类型的实例化
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123005509">https://blog.csdn.net/Dong_HFUT/article/details/123005509</a></li>
</ul>
</li>
</ul>
<h1 id="12给意在改写的函数添加override声明">12：给意在改写的函数添加override声明</h1>
<ul>
<li>重写override需要满足的条件
<ul>
<li>基类的重写函数必须是虚函数</li>
<li>基类和派生类的重写函数
<ul>
<li>函数名（析构函数除外）、形参类型、函数常量性完全相同</li>
<li>函数引用限定符完全相同（C++11，函数引用限定符：该成员函数可以被左值对象还是右值对象调用）</li>
<li>返回值类型、异常规格说明兼容</li>
</ul>
</li>
</ul>
</li>
<li>将重写的函数标记为<code>override</code>，如果不满足重写条件则报错</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123008755">https://blog.csdn.net/Dong_HFUT/article/details/123008755</a></li>
</ul>
</li>
</ul>
<h1 id="13优先选用const_iterator而非iterator">13：优先选用<code>const_iterator</code>，而非<code>iterator</code></h1>
<ul>
<li>C++98在容器的成员函数中对<code>const_iterator</code>支持有限</li>
<li>C++11在容器的成员函数中支持<code>const_iterator</code>，但是只提供了非成员的begin和end
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">&gt;</span> <span class="c1">// C++11实现cbegin的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">cbegin</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">)){</span> <span class="c1">// auto=const Container::iterator&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>C++14提供了非成员的cbegin和cend</li>
<li>尽量使用非成员的cbegin和cend，因为某些数据结构（比如数组）没有成员函数cbegin和cend，非成员的cbegin和cend更加通用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">targetVal</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insertVal</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">targetVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123030976">https://blog.csdn.net/Dong_HFUT/article/details/123030976</a></li>
</ul>
</li>
</ul>
<h1 id="14只要函数不会抛出异常就为其加上noexcept声明">14：只要函数不会抛出异常，就为其加上<code>noexcept</code>声明</h1>
<blockquote>
<ul>
<li>noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。</li>
<li>相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。</li>
<li>noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。</li>
<li>大部分函数是异常中立的而不是 noexcept。</li>
</ul>
</blockquote>
<ul>
<li>背景：
<ul>
<li>C++98中异常规范的局限性：接口的实现一旦被修改，其异常规范可能也变化</li>
<li>因此C++11只需要指明接口是否可能抛出异常</li>
</ul>
</li>
<li>优点：一个<code>noexcept</code>函数有更多编译优化的机会
<ul>
<li>不需要保持运行栈为解开的状态</li>
<li>不需要保证对象以构造顺序的逆序完成析构</li>
</ul>
</li>
<li>应用：如果知道一个函数不会抛出异常，一定要加上<code>noexcept</code>
<ul>
<li><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略</li>
<li>默认<code>noexcept</code>函数：C++11内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性
<ul>
<li>析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包含递归的成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code></li>
<li>如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</li>
</ul>
</li>
</ul>
</li>
<li>条件<code>noexcept</code>：一个函数是否为<code>noexcept</code>，取决于<code>noexcept</code>中的表达式是否为<code>noexcept</code>
<ul>
<li>只有被调用的低层次的函数是<code>noexcept</code>，高层次的调用方才是<code>noexcept</code>的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">myPair</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">myPair</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">))</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>异常中立函数：本身不抛出异常，但是调用的函数可能抛出异常，因此不适合标记为<code>noexcept</code>
<ul>
<li>但是允许<code>noexcept</code>函数中调用没有<code>noexcept</code>保证的函数</li>
</ul>
</li>
<li>通常只为宽松规约提供<code>noexcept</code>声明
<ul>
<li>宽松规约（wide contract，宽接口）：不带前提条件，被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为</li>
<li>狭隘规约（narrow contract，窄接口）：带前提条件，如果违反前提条件，则结果是未定义的
<ul>
<li>调用者来保证调用时满足前提条件</li>
<li>如果调用时违反前提条件，则抛出异常；如果定义为<code>noexcept</code>的，违反前提条件结果是未定义的；相较而言，找出抛出异常的原因相对简单一些</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123163671">https://blog.csdn.net/Dong_HFUT/article/details/123163671</a></li>
</ul>
</li>
</ul>
<h1 id="15只要有可能使用constexpr就使用它">15：只要有可能使用<code>constexpr</code>，就使用它</h1>
<ul>
<li><code>constexpr</code>对象：具备const属性，并且在编译期（和链接期）可以确定其值
<ul>
<li>const对象不能保证在编译期确定其值</li>
</ul>
</li>
<li><code>constexpr</code>函数
<ul>
<li>含义：
<ul>
<li>如果所有传入 constexpr 函数的参数都能在编译时知道，则结果将在编译时计算出来。</li>
<li>如果传入 constexpr 函数的参数有任何一个不能在编译期知道，则结果在运行时计算出来</li>
</ul>
</li>
<li>使用
<ul>
<li>C++11中，<code>constexpr</code>函数有且只能有一条return语句；C++14无此限制</li>
<li>constexpr 函数被限制只能接受和返回 literal 类型（字面量，非指针和引用，自定义类型也可能是字面量类型的）</li>
<li>C++11中，如果成员函数修改了操作的对象，或者成员函数的返回值是void的，则该成员函数无法成为<code>constexpr</code>的；C++14无此限制</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">xVal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">yVal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">xVal</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">yVal</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getX</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getY</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">y</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;}</span> <span class="c1">// C++14中，移除了两条限制，因此可以设置为constexpr的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">constexprt</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123172189">https://blog.csdn.net/Dong_HFUT/article/details/123172189</a></li>
</ul>
</li>
</ul>
<h1 id="16保证const成员函数的线程安全性">16：保证const成员函数的线程安全性</h1>
<ul>
<li>const成员的好处：不会修改成员变量，而且可以区分重载（const对象和非const对象调用）</li>
<li>保证const成员函数的线程安全性
<ul>
<li>使用<code>std::mutex</code>，进入临界区锁对象获取互斥量，出临界区析构锁（释放互斥量）</li>
<li>使用<code>std::atomic</code>，但是只能同步单一变量或者内存单元</li>
<li><code>std::mutex</code>和<code>std::atomic</code>都是move-only的</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123316263">https://blog.csdn.net/Dong_HFUT/article/details/123316263</a></li>
</ul>
</li>
</ul>
<h1 id="17理解特殊成员函数的生成机制">17：理解特殊成员函数的生成机制</h1>
<ul>
<li>特殊成员函数（special member function）：
<ul>
<li>一般是public、inline和novirtual的
<ul>
<li>例外：如果基类中的析构函数是virtual的，派生类中的析构函数也是virtual的</li>
</ul>
</li>
<li>拷贝构造和拷贝赋值是两个独立的操作</li>
<li>移动构造和移动赋值不是独立的操作，如果声明了其中一个，编译器会阻止生成另外一个</li>
<li>如果显式申明一个拷贝操作，则两个移动操作不会自动生成</li>
</ul>
</li>
<li>三法则（The Rule of Three）：如果声明了{拷贝构造函数、拷贝赋值操作、析构函数}中任意一个，则应该声明所有这三个函数，因为往往意味着类要管理某些资源
<ul>
<li>因此，如果只声明了一个析构函数，编译器应该不会自动生成拷贝操作</li>
<li>但实际上编译器还是可能自动生成拷贝操作（历史遗留原因，以及C++11为了兼容历史代码）</li>
<li>因此，只有当类中没有声明析构函数、拷贝操作、移动操作，而且需要时，编译器才会生成移动操作</li>
</ul>
</li>
<li>如果想让编译器自动生成相关函数（即使违背了这些限制），添加<code>=default</code>进行标记</li>
<li>C++11中对特殊成员函数的生成规则：
<ul>
<li>默认构造函数：同C++98</li>
<li>析构函数：本质同C++98，只是默认声明为<code>noexcept</code></li>
<li>拷贝构造函数：运行期行为同C++98（memberwise 拷贝构造 non-static 成员变量）
<ul>
<li>如果类中声明了一个移动操作，则拷贝构造函数和拷贝赋值运算符被标记为<code>=delete</code>的</li>
<li>如果类中自定义拷贝赋值运算符或析构函数，可以生成拷贝构造函数，但是已经成为被废弃的方法</li>
</ul>
</li>
<li>拷贝赋值运算符：规则同拷贝构造函数</li>
<li>移动构造函数和移动赋值运算符：仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成</li>
</ul>
</li>
<li>特殊情况：成员模板函数不会抑制特殊成员函数的自动生成
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> <span class="c1">// 编译器仍然会生成copy和move操作，即使可以实例化得到
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559">https://blog.csdn.net/Dong_HFUT/article/details/123433559</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch02 Auto</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/</guid>
      <description>05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写</description>
      <content:encoded><![CDATA[<h1 id="05优先选用auto而非显式类型推断">05：优先选用auto，而非显式类型推断</h1>
<ul>
<li>优点一：避免变量未初始化
<ul>
<li>使用auto声明的变量未初始化，直接导致编译报错</li>
</ul>
</li>
<li>优点二：简化变量声明（避免写一长串类型名）</li>
<li>优点三：声明闭包类型（lambda表达式）
<ul>
<li>C++11中lambda式返回值可以使用auto，C++14中lambda式形参也可以使用auto</li>
<li><code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。
<ul>
<li>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同</li>
<li>使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。</li>
</ul>
</li>
</ul>
</li>
<li>优点四：避免类型截断</li>
<li>优点五：避免类型不匹配
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span><span class="p">:</span> <span class="n">mp</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// auto=std::pair&lt;const std::string,int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 但是如果显式定义类型，很容易定义为std::pair&lt;std::string, int&gt;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h1 id="06当auto推导的类型不符合要求时使用带显式类型的初始化习惯用法">06：当auto推导的类型不符合要求时，使用带显式类型的初始化习惯用法</h1>
<blockquote>
<ul>
<li>隐式的代理类型可能导致auto类型推导结果不符合预期，因此应该显式声明类型</li>
</ul>
</blockquote>
<ul>
<li>代理类：模拟和拓展某些其他类型的行为，比如智能指针，比如<code>std::vector&lt;bool&gt;::reference</code>
<ul>
<li><code>std::vector&lt;bool&gt;</code>进行了特化，与一般<code>std::vector</code>不同：
<ul>
<li>一般对于<code>vector&lt;T&gt;</code>的<code>operator []</code>操作，返回类型为<code>T&amp;</code>；但是对于<code>vector&lt;bool&gt;</code>的<code>operator []</code>操作，返回类型为<code>vector&lt;bool&gt;::reference</code>（因此可能发生到<code>bool</code>的隐式类型转换），这是因为标准库无法返回对bit的引用</li>
<li><code>vector&lt;bool&gt;::reference</code>的实现中，可能有一个指向word的指针和一个对应的offset，很可能出现难以预料的错误
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">flg</span> <span class="o">=</span> <span class="n">func</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// func()返回一个临时的右值对象，flg是vector&lt;bool&gt;::reference类型，然后临时的右值对象被析构
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因为vector&lt;bool&gt;::reference类型中可能有一个指针，再使用flg可能出现未定义的行为
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>表达式模板中，计算结果可能被解析为一棵语法解析树，而非直接返回计算结果，因此实际得到的结果类型（语法解析树）可能并非期望的类型
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/441617539"># C++元编程之表达式模板优化数组计算</a></li>
</ul>
</li>
</ul>
</li>
<li>总之，对(隐形)代理类的auto类型推导往往得到的不是预期的类型，因此要么显式声明类型，要么使用<code>static_cast</code>强转然后进行auto类型推导</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch01 类型推导</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:04 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</guid>
      <description>01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特</description>
      <content:encoded><![CDATA[<h1 id="01理解模板类型推导">01：理解模板类型推导</h1>
<blockquote>
<ul>
<li>在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。
- 在万能引用参数类型推导时，左值参数被特殊处理。
- 值传递形参的类型推导时，其 <em>const</em> 和 <em>volatile</em> 被忽略。
- 在模板类型推导时，数组或者函数类型被转换为指针类型，除非它们用来初始化引用。</li>
</ul>
</blockquote>
<ul>
<li>背景：有时模板类型推导无法一下看出来T是什么类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span> <span class="c1">// 比如实参可能是int, const int, const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>类型T的推导不仅取决于expr的类型，也取决于ParamType的形式</li>
</ul>
</li>
<li>情况一：ParamType是指针或引用，但不是万能引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>情况二：ParamType是万能引用，因此可能发生引用折叠</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>情况三：ParamType不是指针，也不是引用，因此视为值传递（实参的const/volatile性质被忽略，因为值进行了复制，形参副本不影响原来的实参）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>特殊情况一：传入的实参为数组类型
<ul>
<li>如果模板是情况一：推导出T为数组类型（包含类型和元素数量）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// 推导出T=const char[6], f(const char(&amp;param)[6])
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>应用：比如可以在编译阶段计算数组元素个数：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">N</span><span class="p">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果模板是情况三：将数组名视为指针，因此T是指针类型</li>
</ul>
</li>
<li>特殊情况二：传入的实参为函数类型
<ul>
<li>如果模板是情况一：推导出T为函数引用类型</li>
<li>如果模板是情况三：推导出T为函数指针类型</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122727237">https://blog.csdn.net/Dong_HFUT/article/details/122727237</a></li>
</ul>
</li>
</ul>
<h1 id="02理解auto类型推导">02：理解auto类型推导</h1>
<blockquote>
<ul>
<li>一般情况下，auto类型推导和模板类型推导完全相同；但是auto类型推导会假定使用<code>{}</code>的列表初始化表达式是一个<code>std::initializer_list</code>，但是模板类型推导不会</li>
<li>在函数返回值或lambda式形参中使用auto，意思是使用模板类型推导而非使用auto类型推导</li>
</ul>
</blockquote>
<ul>
<li>背景：将一个变量赋值给auto类型变量，auto是什么类型</li>
<li>同[[ch01-类型推导#01：理解模板类型推导|01：理解模板类型推导]]中的总体原则：将实参赋值给形参
<ul>
<li>除了一个例外：使用<code>{}</code>进行列表初始化</li>
<li>auto类型推导：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="c1">// auto=std::initializer_list&lt;int&gt;,首先推导为std::initializer_list&lt;T&gt;，然后再推断类型T=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">y</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span> <span class="c1">// auto=int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>模板类型推导：不能直接将<code>{}</code>的列表初始化表达式推导为<code>T=std::initializer_list&lt;type&gt;</code>，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// 报错：直接传入{}列表初始化的实参，模板类型推导失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">initList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// T=int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><a href="https://stackoverflow.com/questions/17582667/why-do-auto-and-template-type-deduction-differ-for-braced-initializers">为什么两种行为不同的一个可能解释</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 左边推导出T=vector&lt;int&gt;, 右边如果推导出T=initializer_list&lt;int&gt;,则左右冲突
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>auto可以作为函数返回值类型、lambda式形参类型（C++14）
<ul>
<li>但是原理是模板类型推导，而非auto类型推导</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122740091">https://blog.csdn.net/Dong_HFUT/article/details/122740091</a></li>
</ul>
</li>
</ul>
<h1 id="03理解decltype">03：理解<code>decltype</code></h1>
<blockquote>
<ul>
<li>绝大多数情况下，decltype会得到变量或表达式的类型，而不进行修改</li>
<li>对于类型为T的左值表达式，除非该表达式只有一个名字，否则decltype总是返回T&amp;</li>
<li>C++14支持<code>decltype(auto)</code>：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导</li>
</ul>
</blockquote>
<ul>
<li>背景：给定一个名字或表达式，<code>decltype</code>返回其类型：原来是值/左值/右值，返回值/左值/右值</li>
<li>体会auto类型推导和decltype类型推导的区别
<ul>
<li>auto类型推导：将变量<code>rhs</code>赋值给<code>lhs</code>，推导出<code>lhs</code>的类型</li>
<li>decltype类型推导：返回变量<code>rhs</code>的类型</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>声明一个函数模板，其返回值类型取决于参数类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltpye</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是引用T&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果返回值为auto，使用auto类型推导，返回类型将不是引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是T
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以同时使用auto和<code>deltype</code>：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是引用T&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>优化与完善：为了传入右值的<code>Container</code>，使用万能引用，同时使用完美转发
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// C++14，或者C++11使用尾置返回类型
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>一般而言decltype返回的类型都比较直观，除了一种情况：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// decltype(x)=int
</span></span></span><span class="line"><span class="cl"><span class="c1">// decltype((x))=int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122745518">https://blog.csdn.net/Dong_HFUT/article/details/122745518</a></li>
<li><a href="https://zyfforlinux.blog.csdn.net/article/details/52658452">https://zyfforlinux.blog.csdn.net/article/details/52658452</a></li>
</ul>
</li>
</ul>
<h1 id="04掌握查看类型推导结果的方法">04：掌握查看类型推导结果的方法</h1>
<ul>
<li>在代码编辑阶段查看类型推导结果：IDE</li>
<li>在代码编译阶段查看类型推导结果：查看编译报错</li>
<li>在代码运行阶段查看类型推导结果：
<ul>
<li><code>typeid</code>：不同编译期实现不同，无法保证完全可靠，而且类型的引用、const、volatile等性质被忽略</li>
<li>Boost库的模板函数<code>boost::typeindex::type_id_with_cvr</code>
<ul>
<li>如果类型不包含引用、const、volatile等性质，则<code>type_id_with_cvr</code>与<code>typeid</code>返回相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span> <span class="c1">// c:const, v:volatile, r:reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
