<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43; | Paul&#39;s Blog</title>
<meta name="keywords" content="cpp">
<meta name="description" content="07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限">
<meta name="author" content="Paul">
<link rel="canonical" href="localhost/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/">
<link crossorigin="anonymous" href="/localhost/assets/css/stylesheet.min.b4949dd90fc0cfca1383007b68f21e23eeac969bc9cadb020d878bf3643b4be1.css" integrity="" rel="preload stylesheet" as="style">

<link rel="icon" href="localhost/favicon.ico">
<link rel="apple-touch-icon" href="localhost/apple-touch-icon.png">

<meta name="twitter:title" content="[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43; | Paul&#39;s Blog" />
<meta name="twitter:description" content="07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限" />
<meta property="og:title" content="[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43; | Paul&#39;s Blog" />
<meta property="og:description" content="07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限" />
<meta property="og:type" content="article" />
<meta property="og:url" content="localhost/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2024-02-01T21:47:37&#43;08:00" />
  <meta property="article:modified_time" content="2024-02-01T21:47:37&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Post",
      "item": "localhost/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "[Effective Modern Cpp Notes] Ch03 转向现代C++",
      "item": "localhost/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c++/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Effective Modern Cpp Notes] Ch03 转向现代C++ | Paul's Blog",
  "name": "[Effective Modern Cpp Notes] Ch03 转向现代C\u002b\u002b",
  "description": "07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限",
  "keywords": [
    "cpp"
  ],
  "wordCount" : "5411",
  "inLanguage": "en",
  "datePublished": "2024-02-01T21:47:37+08:00",
  "dateModified": "2024-02-01T21:47:37+08:00",
  "author":{
    "@type": "Person",
    "name": "Paul"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "localhost/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c++/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Paul's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "localhost/favicon.ico"
    }
  }
}
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css"
    integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" 
    crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js"
    integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true },
                
                
                
                
                
                
                
                
                
                
            ],
            
            throwOnError: false
        });
    });
</script>


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="localhost" accesskey="h" title="Paul&#39;s Blog (Alt + H)">Paul&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="localhost/localhost/posts/" title="Posts"
                >Posts
                </a>
            </li>
            <li>
                <a href="localhost/localhost/archives/" title="Archive"
                >Archive
                </a>
            </li>
            <li>
                <a href="localhost/localhost/search/" title="Search (Alt &#43; /)"data-no-instant accesskey=/
                >Search
                </a>
            </li>
            <li>
                <a href="localhost/localhost/tags/" title="Tags"
                >Tags
                </a>
            </li>
            <li>
                <a href="localhost/localhost/categories/" title="Categories"
                >Categories
                </a>
            </li>
            <li>
                <a href="localhost/localhost/about/" title="About"
                >About
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="localhost">Home</a>&nbsp;»&nbsp;<a href="localhost/posts/">Post</a></div><h1 class="post-title">[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43;</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2024-02-01</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="localhost/tags/cpp/">cpp</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path><polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline><line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line><line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line><polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline></svg>
  <span>5411 words</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>11 min</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#07%e5%9c%a8%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1%e6%97%b6%e6%b3%a8%e6%84%8f%e5%8c%ba%e5%88%86%e5%92%8c" aria-label="07：在创建对象时注意区分()和{}">07：在创建对象时注意区分<code>()</code>和<code>{}</code></a></li>
                <li>
                    <a href="#08%e4%bc%98%e5%85%88%e9%80%89%e7%94%a8nullptr%e8%80%8c%e9%9d%9e0%e6%88%96null" aria-label="08：优先选用nullptr，而非0或NULL">08：优先选用nullptr，而非0或NULL</a></li>
                <li>
                    <a href="#09%e4%bc%98%e5%85%88%e9%80%89%e7%94%a8%e5%88%ab%e5%90%8d%e5%a3%b0%e6%98%8e%e8%80%8c%e9%9d%9etypedef" aria-label="09：优先选用别名声明，而非typedef">09：优先选用别名声明，而非typedef</a></li>
                <li>
                    <a href="#10%e4%bc%98%e5%85%88%e9%80%89%e7%94%a8%e9%99%90%e5%ae%9a%e4%bd%9c%e7%94%a8%e5%9f%9f%e7%9a%84%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b%e8%80%8c%e9%9d%9e%e4%b8%8d%e9%99%90%e4%bd%9c%e7%94%a8%e5%9f%9f%e7%9a%84%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b" aria-label="10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型">10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</a></li>
                <li>
                    <a href="#11%e4%bc%98%e5%85%88%e9%80%89%e7%94%a8%e5%88%a0%e9%99%a4%e5%87%bd%e6%95%b0%e8%80%8c%e9%9d%9eprivate%e6%9c%aa%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0" aria-label="11：优先选用删除函数，而非private未定义函数">11：优先选用删除函数，而非private未定义函数</a></li>
                <li>
                    <a href="#12%e7%bb%99%e6%84%8f%e5%9c%a8%e6%94%b9%e5%86%99%e7%9a%84%e5%87%bd%e6%95%b0%e6%b7%bb%e5%8a%a0override%e5%a3%b0%e6%98%8e" aria-label="12：给意在改写的函数添加override声明">12：给意在改写的函数添加override声明</a></li>
                <li>
                    <a href="#13%e4%bc%98%e5%85%88%e9%80%89%e7%94%a8const_iterator%e8%80%8c%e9%9d%9eiterator" aria-label="13：优先选用const_iterator，而非iterator">13：优先选用<code>const_iterator</code>，而非<code>iterator</code></a></li>
                <li>
                    <a href="#14%e5%8f%aa%e8%a6%81%e5%87%bd%e6%95%b0%e4%b8%8d%e4%bc%9a%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8%e5%b0%b1%e4%b8%ba%e5%85%b6%e5%8a%a0%e4%b8%8anoexcept%e5%a3%b0%e6%98%8e" aria-label="14：只要函数不会抛出异常，就为其加上noexcept声明">14：只要函数不会抛出异常，就为其加上<code>noexcept</code>声明</a></li>
                <li>
                    <a href="#15%e5%8f%aa%e8%a6%81%e6%9c%89%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8constexpr%e5%b0%b1%e4%bd%bf%e7%94%a8%e5%ae%83" aria-label="15：只要有可能使用constexpr，就使用它">15：只要有可能使用<code>constexpr</code>，就使用它</a></li>
                <li>
                    <a href="#16%e4%bf%9d%e8%af%81const%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%80%a7" aria-label="16：保证const成员函数的线程安全性">16：保证const成员函数的线程安全性</a></li>
                <li>
                    <a href="#17%e7%90%86%e8%a7%a3%e7%89%b9%e6%ae%8a%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e7%94%9f%e6%88%90%e6%9c%ba%e5%88%b6" aria-label="17：理解特殊成员函数的生成机制">17：理解特殊成员函数的生成机制</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="07在创建对象时注意区分和">07：在创建对象时注意区分<code>()</code>和<code>{}</code><a hidden class="anchor" aria-hidden="true" href="#07在创建对象时注意区分和">¶</a></h1>
<ul>
<li>初始化方式
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">x1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x3</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 统一初始化（列表初始化）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// 和第三种方式相同
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>()</code>和<code>=</code>初始化的限制
<ul>
<li><code>()</code>不能用于non-static成员的初始化</li>
<li>不能拷贝的对象不能使用<code>()</code>初始化</li>
</ul>
</li>
<li><code>{}</code>初始化的优点
<ul>
<li>禁止基本类型之间的隐式窄化类型转换：比如不能使用double初始化int型变量</li>
<li>避免了C++复杂的语法分析：<a href="https://blog.csdn.net/Dong_HFUT/article/details/126435993">C++&rsquo;s most vexing parse</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 传入一个实参，构造出一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w2</span><span class="p">();</span> <span class="c1">// 本来想调用无形参的构造函数构造一个对象，但是实际上声明了一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{};</span> <span class="c1">// 调用无形参的构造函数，构造出一个对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>{}</code>的缺陷
<ul>
<li>auto类型推导中使用<code>{}</code>进行初始化，则auto被推断为<code>initializer_list&lt;T&gt;</code></li>
<li>会优先使用形参为<code>initializer_list&lt;T&gt;</code>的构造函数，即使其他的构造函数更加匹配
<ul>
<li>只有当<code>{}</code>中参数无法转换为<code>initializer_list</code>中类型时，编译器才匹配普通函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;0&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;move copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;convert to int&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(int i, bool d)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span> <span class="c1">// 编译报错，本来调用Widget(initializer_list&lt;int&gt; il)，但是使用{}初始化禁止窄化类型转换（存在从double到int的转换）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{</span><span class="n">w1</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)（中间先将w1转为int），即使Widget(const Widget&amp; w)更加匹配（如果w1无法转换为int，则调用该构造函数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w1</span><span class="p">)};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(Widget&amp;&amp; w)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 特殊情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{};</span> <span class="c1">// 调用Widget()，而非调用Widget(initializer_list&lt;int&gt; il)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w5</span><span class="p">{{}};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w6</span><span class="p">({});</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>使用模板创建对象时，仔细考虑使用<code>()</code>还是<code>{}</code>进行初始化
<ul>
<li>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">){</span> <span class="c1">// 使用可变参数模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="nf">localVector1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">localVector2</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 推断出T=vector&lt;int&gt;, Ts=int
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector1: 4,4,4
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector2: 3,4
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122811753">https://blog.csdn.net/Dong_HFUT/article/details/122811753</a></li>
</ul>
</li>
</ul>
<h1 id="08优先选用nullptr而非0或null">08：优先选用nullptr，而非0或NULL<a hidden class="anchor" aria-hidden="true" href="#08优先选用nullptr而非0或null">¶</a></h1>
<ul>
<li>字面量0是一个int，NULL的实现为0L，可以转换为int，bool，<code>void*</code></li>
<li><code>nullptr</code>可以理解为任意类型的空指针
<ul>
<li>使得重载函数的调用明确</li>
<li>提高代码的清晰度</li>
<li>使用类型推导时，<code>nullptr</code>可以隐式转换为任意类型指针</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122891898">https://blog.csdn.net/Dong_HFUT/article/details/122891898</a></li>
</ul>
</li>
</ul>
<h1 id="09优先选用别名声明而非typedef">09：优先选用别名声明，而非typedef<a hidden class="anchor" aria-hidden="true" href="#09优先选用别名声明而非typedef">¶</a></h1>
<ul>
<li><code>using</code>别名的优点：
<ul>
<li>清晰，比<code>typedef</code>更容易理解</li>
<li>可以直接对模板起别名
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 如果非要使用typedef，需要包装一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyAllocList</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list1</span><span class="p">;</span> <span class="c1">// list1=std::list&lt;T, MyAlloc&lt;T&gt;&gt;,此时MyAllocList一定是一个别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list2</span><span class="p">;</span> <span class="c1">// list2=MyAllocList&lt;T&gt;中的std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 需要使用typename显式说明MyAllocList&lt;T&gt;::type是一个类型，而非数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>应用：标准库的<code>&lt;type_traits&gt;</code>中提供了一整套用于类型转换的类模板
<ul>
<li>虽然C++11中仍然是使用<code>typedef</code>实现的，但是C++14中是使用<code>using</code>声明实现的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="c1">// C++11中, 是一个内部包裹typedef的类模板，将T中的const属性移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>     <span class="c1">// C++14中, 是一个类模板中typedef别名的别名，将T中的const属性移除
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122847510">https://blog.csdn.net/Dong_HFUT/article/details/122847510</a></li>
</ul>
</li>
</ul>
<h1 id="10优先选用限定作用域的枚举类型而非不限作用域的枚举类型">10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型<a hidden class="anchor" aria-hidden="true" href="#10优先选用限定作用域的枚举类型而非不限作用域的枚举类型">¶</a></h1>
<ul>
<li>无作用域限制的枚举（unscoped enums，C++98）
<ul>
<li>有时使用可能简便一点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">UserInfo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="c1">//name, email,age
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">UserInfoFields</span> <span class="p">{</span><span class="n">uiName</span><span class="p">,</span> <span class="n">uiEmail</span><span class="p">,</span> <span class="n">uiAge</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 位置1为email
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">uiEmail</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 冗余
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// C++14下的辅助类:既想使用有作用限制的枚举，又不想过于啰嗦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">toUType</span><span class="p">(</span><span class="n">E</span> <span class="n">enumerator</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">enumerator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">toUType</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>有作用域限制的枚举（scoped enums，C++11）
<ul>
<li>减少名称污染
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">black</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，因此枚举类型暴露在{}之外
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">red</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 有作用域限制的枚举，枚举类型限制在{}之内，因此减少名称污染
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>有强类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，可以发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d2</span> <span class="o">=</span>  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scopedColor</span><span class="o">::</span><span class="n">red</span><span class="p">);</span> <span class="c1">// 有作用域限制的枚举，不会发生隐式类型转换，类型转换需要显式说明
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以前向声明：只有在指定底层类型后，才能进行前向声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">;</span> <span class="c1">// 没有提供默认底层类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="k">class</span><span class="err">; //默认底层类型为</span><span class="nc">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122914289">https://blog.csdn.net/Dong_HFUT/article/details/122914289</a></li>
</ul>
</li>
</ul>
<h1 id="11优先选用删除函数而非private未定义函数">11：优先选用删除函数，而非private未定义函数<a hidden class="anchor" aria-hidden="true" href="#11优先选用删除函数而非private未定义函数">¶</a></h1>
<ul>
<li>背景：编译期会自动生成某些函数，但是有时不需要这些函数；</li>
<li>C++98的做法：声明为private的，且只声明不定义（effective C++中item6）
<ul>
<li>在private中声明但是不定义，使之在链接阶段因为没有定义而报错</li>
<li>在基类中声明为private的，会因为无法拷贝控制派生类中的基类部分，将报错从链接期提前到编译期</li>
</ul>
</li>
<li>C++11的做法：在声明中标记为<code>=delete</code>
<ul>
<li>将删除的函数声明为public的，原因是编译器先检查访问权限，再检查delete状态。如果将删除的函数声明为private的，调用删除的函数时，可能报错原因提示是private的；但是更期望的更明确的含义是这些函数是删除的</li>
<li><code>=delete</code>可以在任意函数中进行标记，不仅仅局限于成员函数</li>
</ul>
</li>
<li>应用：
<ul>
<li>比如可以阻止某些形参的隐式类型转换
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> <span class="c1">// 因此禁止double和float两种参数的调用（C++总是倾向于将 float 转换为 double）
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>阻止某些模板类型的实例化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 成员模板函数在类外阻止某些类型的实例化
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123005509">https://blog.csdn.net/Dong_HFUT/article/details/123005509</a></li>
</ul>
</li>
</ul>
<h1 id="12给意在改写的函数添加override声明">12：给意在改写的函数添加override声明<a hidden class="anchor" aria-hidden="true" href="#12给意在改写的函数添加override声明">¶</a></h1>
<ul>
<li>重写override需要满足的条件
<ul>
<li>基类的重写函数必须是虚函数</li>
<li>基类和派生类的重写函数
<ul>
<li>函数名（析构函数除外）、形参类型、函数常量性完全相同</li>
<li>函数引用限定符完全相同（C++11，函数引用限定符：该成员函数可以被左值对象还是右值对象调用）</li>
<li>返回值类型、异常规格说明兼容</li>
</ul>
</li>
</ul>
</li>
<li>将重写的函数标记为<code>override</code>，如果不满足重写条件则报错</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123008755">https://blog.csdn.net/Dong_HFUT/article/details/123008755</a></li>
</ul>
</li>
</ul>
<h1 id="13优先选用const_iterator而非iterator">13：优先选用<code>const_iterator</code>，而非<code>iterator</code><a hidden class="anchor" aria-hidden="true" href="#13优先选用const_iterator而非iterator">¶</a></h1>
<ul>
<li>C++98在容器的成员函数中对<code>const_iterator</code>支持有限</li>
<li>C++11在容器的成员函数中支持<code>const_iterator</code>，但是只提供了非成员的begin和end
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">&gt;</span> <span class="c1">// C++11实现cbegin的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">cbegin</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">)){</span> <span class="c1">// auto=const Container::iterator&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>C++14提供了非成员的cbegin和cend</li>
<li>尽量使用非成员的cbegin和cend，因为某些数据结构（比如数组）没有成员函数cbegin和cend，非成员的cbegin和cend更加通用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">targetVal</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insertVal</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">targetVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123030976">https://blog.csdn.net/Dong_HFUT/article/details/123030976</a></li>
</ul>
</li>
</ul>
<h1 id="14只要函数不会抛出异常就为其加上noexcept声明">14：只要函数不会抛出异常，就为其加上<code>noexcept</code>声明<a hidden class="anchor" aria-hidden="true" href="#14只要函数不会抛出异常就为其加上noexcept声明">¶</a></h1>
<blockquote>
<ul>
<li>noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。</li>
<li>相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。</li>
<li>noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。</li>
<li>大部分函数是异常中立的而不是 noexcept。</li>
</ul>
</blockquote>
<ul>
<li>背景：
<ul>
<li>C++98中异常规范的局限性：接口的实现一旦被修改，其异常规范可能也变化</li>
<li>因此C++11只需要指明接口是否可能抛出异常</li>
</ul>
</li>
<li>优点：一个<code>noexcept</code>函数有更多编译优化的机会
<ul>
<li>不需要保持运行栈为解开的状态</li>
<li>不需要保证对象以构造顺序的逆序完成析构</li>
</ul>
</li>
<li>应用：如果知道一个函数不会抛出异常，一定要加上<code>noexcept</code>
<ul>
<li><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略</li>
<li>默认<code>noexcept</code>函数：C++11内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性
<ul>
<li>析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包含递归的成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code></li>
<li>如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</li>
</ul>
</li>
</ul>
</li>
<li>条件<code>noexcept</code>：一个函数是否为<code>noexcept</code>，取决于<code>noexcept</code>中的表达式是否为<code>noexcept</code>
<ul>
<li>只有被调用的低层次的函数是<code>noexcept</code>，高层次的调用方才是<code>noexcept</code>的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">myPair</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">myPair</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">))</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>异常中立函数：本身不抛出异常，但是调用的函数可能抛出异常，因此不适合标记为<code>noexcept</code>
<ul>
<li>但是允许<code>noexcept</code>函数中调用没有<code>noexcept</code>保证的函数</li>
</ul>
</li>
<li>通常只为宽松规约提供<code>noexcept</code>声明
<ul>
<li>宽松规约（wide contract，宽接口）：不带前提条件，被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为</li>
<li>狭隘规约（narrow contract，窄接口）：带前提条件，如果违反前提条件，则结果是未定义的
<ul>
<li>调用者来保证调用时满足前提条件</li>
<li>如果调用时违反前提条件，则抛出异常；如果定义为<code>noexcept</code>的，违反前提条件结果是未定义的；相较而言，找出抛出异常的原因相对简单一些</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123163671">https://blog.csdn.net/Dong_HFUT/article/details/123163671</a></li>
</ul>
</li>
</ul>
<h1 id="15只要有可能使用constexpr就使用它">15：只要有可能使用<code>constexpr</code>，就使用它<a hidden class="anchor" aria-hidden="true" href="#15只要有可能使用constexpr就使用它">¶</a></h1>
<ul>
<li><code>constexpr</code>对象：具备const属性，并且在编译期（和链接期）可以确定其值
<ul>
<li>const对象不能保证在编译期确定其值</li>
</ul>
</li>
<li><code>constexpr</code>函数
<ul>
<li>含义：
<ul>
<li>如果所有传入 constexpr 函数的参数都能在编译时知道，则结果将在编译时计算出来。</li>
<li>如果传入 constexpr 函数的参数有任何一个不能在编译期知道，则结果在运行时计算出来</li>
</ul>
</li>
<li>使用
<ul>
<li>C++11中，<code>constexpr</code>函数有且只能有一条return语句；C++14无此限制</li>
<li>constexpr 函数被限制只能接受和返回 literal 类型（字面量，非指针和引用，自定义类型也可能是字面量类型的）</li>
<li>C++11中，如果成员函数修改了操作的对象，或者成员函数的返回值是void的，则该成员函数无法成为<code>constexpr</code>的；C++14无此限制</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">xVal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">yVal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">xVal</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">yVal</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getX</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getY</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">y</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;}</span> <span class="c1">// C++14中，移除了两条限制，因此可以设置为constexpr的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">constexprt</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123172189">https://blog.csdn.net/Dong_HFUT/article/details/123172189</a></li>
</ul>
</li>
</ul>
<h1 id="16保证const成员函数的线程安全性">16：保证const成员函数的线程安全性<a hidden class="anchor" aria-hidden="true" href="#16保证const成员函数的线程安全性">¶</a></h1>
<ul>
<li>const成员的好处：不会修改成员变量，而且可以区分重载（const对象和非const对象调用）</li>
<li>保证const成员函数的线程安全性
<ul>
<li>使用<code>std::mutex</code>，进入临界区锁对象获取互斥量，出临界区析构锁（释放互斥量）</li>
<li>使用<code>std::atomic</code>，但是只能同步单一变量或者内存单元</li>
<li><code>std::mutex</code>和<code>std::atomic</code>都是move-only的</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123316263">https://blog.csdn.net/Dong_HFUT/article/details/123316263</a></li>
</ul>
</li>
</ul>
<h1 id="17理解特殊成员函数的生成机制">17：理解特殊成员函数的生成机制<a hidden class="anchor" aria-hidden="true" href="#17理解特殊成员函数的生成机制">¶</a></h1>
<ul>
<li>特殊成员函数（special member function）：
<ul>
<li>一般是public、inline和novirtual的
<ul>
<li>例外：如果基类中的析构函数是virtual的，派生类中的析构函数也是virtual的</li>
</ul>
</li>
<li>拷贝构造和拷贝赋值是两个独立的操作</li>
<li>移动构造和移动赋值不是独立的操作，如果声明了其中一个，编译器会阻止生成另外一个</li>
<li>如果显式申明一个拷贝操作，则两个移动操作不会自动生成</li>
</ul>
</li>
<li>三法则（The Rule of Three）：如果声明了{拷贝构造函数、拷贝赋值操作、析构函数}中任意一个，则应该声明所有这三个函数，因为往往意味着类要管理某些资源
<ul>
<li>因此，如果只声明了一个析构函数，编译器应该不会自动生成拷贝操作</li>
<li>但实际上编译器还是可能自动生成拷贝操作（历史遗留原因，以及C++11为了兼容历史代码）</li>
<li>因此，只有当类中没有声明析构函数、拷贝操作、移动操作，而且需要时，编译器才会生成移动操作</li>
</ul>
</li>
<li>如果想让编译器自动生成相关函数（即使违背了这些限制），添加<code>=default</code>进行标记</li>
<li>C++11中对特殊成员函数的生成规则：
<ul>
<li>默认构造函数：同C++98</li>
<li>析构函数：本质同C++98，只是默认声明为<code>noexcept</code></li>
<li>拷贝构造函数：运行期行为同C++98（memberwise 拷贝构造 non-static 成员变量）
<ul>
<li>如果类中声明了一个移动操作，则拷贝构造函数和拷贝赋值运算符被标记为<code>=delete</code>的</li>
<li>如果类中自定义拷贝赋值运算符或析构函数，可以生成拷贝构造函数，但是已经成为被废弃的方法</li>
</ul>
</li>
<li>拷贝赋值运算符：规则同拷贝构造函数</li>
<li>移动构造函数和移动赋值运算符：仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成</li>
</ul>
</li>
<li>特殊情况：成员模板函数不会抑制特殊成员函数的自动生成
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> <span class="c1">// 编译器仍然会生成copy和move操作，即使可以实例化得到
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559">https://blog.csdn.net/Dong_HFUT/article/details/123433559</a></li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="localhost/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">
    <span class="title">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline></svg>&nbsp;Prev Page</span>
    <br>
    <span>[Effective Modern Cpp Notes] Ch04 智能指针</span>
  </a>
  <a class="next" href="localhost/posts/effective-modern-cpp/ch02-auto/">
    <span class="title">Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg>
    </span>
    <br>
    <span>[Effective Modern Cpp Notes] Ch02 Auto</span>
  </a>
</nav>

  </footer>
    <div class="comments-separator"></div>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2024 <a href="localhost">Paul&#39;s Blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/localhost/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied!';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>
